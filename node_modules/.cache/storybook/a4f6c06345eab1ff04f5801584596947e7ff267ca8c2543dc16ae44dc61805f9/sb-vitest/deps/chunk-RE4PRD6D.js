import {
  Channel,
  invariant
} from "./chunk-QLUIIR5G.js";
import {
  clearAllMocks,
  fn2,
  instrument,
  isMockFunction,
  onMockCall,
  resetAllMocks,
  restoreAllMocks,
  uninstrumentedUserEvent,
  within
} from "./chunk-QTHO6G2T.js";
import {
  ARGTYPES_INFO_REQUEST,
  ARGTYPES_INFO_RESPONSE,
  CONFIG_ERROR,
  FORCE_REMOUNT,
  FORCE_RE_RENDER,
  GLOBALS_UPDATED,
  PLAY_FUNCTION_THREW_EXCEPTION,
  PREVIEW_INITIALIZED,
  RESET_STORY_ARGS,
  SET_GLOBALS,
  STORY_ARGS_UPDATED,
  STORY_FINISHED,
  STORY_HOT_UPDATED,
  STORY_INDEX_INVALIDATED,
  STORY_RENDERED,
  STORY_RENDER_PHASE_CHANGED,
  UNHANDLED_ERRORS_WHILE_PLAYING,
  UPDATE_GLOBALS,
  UPDATE_STORY_ARGS
} from "./chunk-KH47UKKM.js";
import {
  require_memoizerific
} from "./chunk-XOGORFPY.js";
import {
  deprecate,
  logger,
  once,
  scope
} from "./chunk-6DO6LUFC.js";
import {
  __commonJS,
  __export,
  __toESM,
  dedent
} from "./chunk-77HHKVKC.js";

// node_modules/storybook/dist/_browser-chunks/chunk-IPA5A322.js
function isTestEnvironment() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return false;
  }
}
function pauseAnimations(atEnd = true) {
  if (!("document" in globalThis && "createElement" in globalThis.document))
    return () => {
    };
  let disableStyle = document.createElement("style");
  disableStyle.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(disableStyle);
  let pauseStyle = document.createElement("style");
  return pauseStyle.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${atEnd ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(pauseStyle), document.body.clientHeight, document.head.removeChild(disableStyle), () => {
    pauseStyle.parentNode?.removeChild(pauseStyle);
  };
}
async function waitForAnimations(signal) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
    return;
  let timedOut = false;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((resolve) => {
      setTimeout(() => {
        let animationRoots = [globalThis.document, ...getShadowRoots(globalThis.document)], checkAnimationsFinished = async () => {
          if (timedOut || signal?.aborted)
            return;
          let runningAnimations = animationRoots.flatMap((el) => el?.getAnimations?.() || []).filter((a) => a.playState === "running" && !isInfiniteAnimation(a));
          runningAnimations.length > 0 && (await Promise.all(runningAnimations.map((a) => a.finished)), await checkAnimationsFinished());
        };
        checkAnimationsFinished().then(resolve);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (resolve) => setTimeout(() => {
        timedOut = true, resolve(void 0);
      }, 5e3)
    )
  ]);
}
function getShadowRoots(doc) {
  return [doc, ...doc.querySelectorAll("*")].reduce((acc, el) => ("shadowRoot" in el && el.shadowRoot && acc.push(el.shadowRoot, ...getShadowRoots(el.shadowRoot)), acc), []);
}
function isInfiniteAnimation(anim) {
  if (anim instanceof CSSAnimation && anim.effect instanceof KeyframeEffect && anim.effect.target) {
    let style = getComputedStyle(anim.effect.target, anim.effect.pseudoElement), index = style.animationName?.split(", ").indexOf(anim.animationName);
    return style.animationIterationCount.split(", ")[index] === "infinite";
  }
  return false;
}

// node_modules/storybook/dist/_browser-chunks/chunk-JVRDBUUP.js
function parseErrorCode({
  code,
  category
}) {
  let paddedCode = String(code).padStart(4, "0");
  return `SB_${category}_${paddedCode}`;
}
function appendErrorRef(url) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(url))
    return url;
  try {
    let urlObj = new URL(url);
    return urlObj.searchParams.set("ref", "error"), urlObj.toString();
  } catch {
    return url;
  }
}
var StorybookError = class _StorybookError extends Error {
  constructor(props) {
    super(_StorybookError.getFullMessage(props));
    this.data = {};
    this.fromStorybook = true;
    this.isHandledError = false;
    this.subErrors = [];
    this.category = props.category, this.documentation = props.documentation ?? false, this.code = props.code, this.isHandledError = props.isHandledError ?? false, this.name = props.name, this.subErrors = props.subErrors ?? [];
  }
  get fullErrorCode() {
    return parseErrorCode({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    let errorName = this._name || this.constructor.name;
    return `${this.fullErrorCode} (${errorName})`;
  }
  set name(name) {
    this._name = name;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation,
    code,
    category,
    message
  }) {
    let page;
    return documentation === true ? page = `https://storybook.js.org/error/${parseErrorCode({ code, category })}?ref=error` : typeof documentation == "string" ? page = appendErrorRef(documentation) : Array.isArray(documentation) && (page = `
${documentation.map((doc) => `	- ${appendErrorRef(doc)}`).join(`
`)}`), `${message}${page != null ? `

More info: ${page}
` : ""}`;
  }
};

// node_modules/storybook/dist/_browser-chunks/chunk-7S2XPX5M.js
var Category = ((Category2) => (Category2.BLOCKS = "BLOCKS", Category2.DOCS_TOOLS = "DOCS-TOOLS", Category2.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", Category2.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", Category2.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", Category2.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", Category2.PREVIEW_API = "PREVIEW_API", Category2.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", Category2.PREVIEW_ROUTER = "PREVIEW_ROUTER", Category2.PREVIEW_THEMING = "PREVIEW_THEMING", Category2.RENDERER_HTML = "RENDERER_HTML", Category2.RENDERER_PREACT = "RENDERER_PREACT", Category2.RENDERER_REACT = "RENDERER_REACT", Category2.RENDERER_SERVER = "RENDERER_SERVER", Category2.RENDERER_SVELTE = "RENDERER_SVELTE", Category2.RENDERER_VUE = "RENDERER_VUE", Category2.RENDERER_VUE3 = "RENDERER_VUE3", Category2.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", Category2.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", Category2.ADDON_VITEST = "ADDON_VITEST", Category2.ADDON_A11Y = "ADDON_A11Y", Category2))(Category || {});
var MissingStoryAfterHmrError = class extends StorybookError {
  constructor(data) {
    super({
      name: "MissingStoryAfterHmrError",
      category: "PREVIEW_API",
      code: 1,
      message: dedent`
        Couldn't find story matching id '${data.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${data.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    });
    this.data = data;
  }
};
var ImplicitActionsDuringRendering = class extends StorybookError {
  constructor(data) {
    super({
      name: "ImplicitActionsDuringRendering",
      category: "PREVIEW_API",
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: dedent`
        We detected that you use an implicit action arg while ${data.phase} of your story.  
        ${data.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${data.name}: fn()
          }`
    });
    this.data = data;
  }
};
var CalledExtractOnStoreError = class extends StorybookError {
  constructor() {
    super({
      name: "CalledExtractOnStoreError",
      category: "PREVIEW_API",
      code: 3,
      message: dedent`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
};
var MissingRenderToCanvasError = class extends StorybookError {
  constructor() {
    super({
      name: "MissingRenderToCanvasError",
      category: "PREVIEW_API",
      code: 4,
      message: dedent`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
};
var CalledPreviewMethodBeforeInitializationError = class extends StorybookError {
  constructor(data) {
    super({
      name: "CalledPreviewMethodBeforeInitializationError",
      category: "PREVIEW_API",
      code: 5,
      message: dedent`
        Called \`Preview.${data.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${data.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    });
    this.data = data;
  }
};
var StoryIndexFetchError = class extends StorybookError {
  constructor(data) {
    super({
      name: "StoryIndexFetchError",
      category: "PREVIEW_API",
      code: 6,
      message: dedent`
        Error fetching \`/index.json\`:
        
        ${data.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    });
    this.data = data;
  }
};
var MissingStoryFromCsfFileError = class extends StorybookError {
  constructor(data) {
    super({
      name: "MissingStoryFromCsfFileError",
      category: "PREVIEW_API",
      code: 10,
      message: dedent`
        Couldn't find story matching id '${data.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    });
    this.data = data;
  }
};
var StoryStoreAccessedBeforeInitializationError = class extends StorybookError {
  constructor() {
    super({
      name: "StoryStoreAccessedBeforeInitializationError",
      category: "PREVIEW_API",
      code: 11,
      message: dedent`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
};
var MountMustBeDestructuredError = class extends StorybookError {
  // name: 'MountMustBeDestructuredError';
  constructor(data) {
    super({
      name: "MountMustBeDestructuredError",
      category: "PREVIEW_API",
      code: 12,
      message: dedent`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${data.playFunction}`
    });
    this.data = data;
  }
};
var NoRenderFunctionError = class extends StorybookError {
  constructor(data) {
    super({
      name: "NoRenderFunctionError",
      category: "PREVIEW_API",
      code: 14,
      message: dedent`
        No render function available for storyId '${data.id}'
      `
    });
    this.data = data;
  }
};
var NoStoryMountedError = class extends StorybookError {
  constructor() {
    super({
      name: "NoStoryMountedError",
      category: "PREVIEW_API",
      code: 15,
      message: dedent`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          // ðŸ‘ˆ mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
};
var StatusTypeIdMismatchError = class extends StorybookError {
  constructor(data) {
    super({
      name: "StatusTypeIdMismatchError",
      category: "PREVIEW_API",
      code: 16,
      message: `Status has typeId "${data.status.typeId}" but was added to store with typeId "${data.typeId}". Full status: ${JSON.stringify(
        data.status,
        null,
        2
      )}`
    });
    this.data = data;
  }
};
var UnsupportedViewportDimensionError = class extends StorybookError {
  constructor(data) {
    super({
      name: "UnsupportedViewportDimensionError",
      category: "ADDON_VITEST",
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: dedent`
        Encountered an unsupported value "${data.value}" when setting the viewport ${data.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    });
    this.data = data;
  }
};
var ElementA11yParameterError = class extends StorybookError {
  constructor() {
    super({
      name: "ElementA11yParameterError",
      category: "ADDON_A11Y",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
      message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
    });
  }
};

// node_modules/storybook/dist/_browser-chunks/chunk-GFLS4VP3.js
function isPlainObject(value) {
  if (!value || typeof value != "object")
    return false;
  let proto = Object.getPrototypeOf(value);
  return proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null ? Object.prototype.toString.call(value) === "[object Object]" : false;
}
function isPrimitive(value) {
  return value == null || typeof value != "object" && typeof value != "function";
}
function isTypedArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var regexpTag = "[object RegExp]";
var stringTag = "[object String]";
var numberTag = "[object Number]";
var booleanTag = "[object Boolean]";
var argumentsTag = "[object Arguments]";
var symbolTag = "[object Symbol]";
var dateTag = "[object Date]";
var mapTag = "[object Map]";
var setTag = "[object Set]";
var arrayTag = "[object Array]";
var functionTag = "[object Function]";
var arrayBufferTag = "[object ArrayBuffer]";
var objectTag = "[object Object]";
var errorTag = "[object Error]";
var dataViewTag = "[object DataView]";
var uint8ArrayTag = "[object Uint8Array]";
var uint8ClampedArrayTag = "[object Uint8ClampedArray]";
var uint16ArrayTag = "[object Uint16Array]";
var uint32ArrayTag = "[object Uint32Array]";
var bigUint64ArrayTag = "[object BigUint64Array]";
var int8ArrayTag = "[object Int8Array]";
var int16ArrayTag = "[object Int16Array]";
var int32ArrayTag = "[object Int32Array]";
var bigInt64ArrayTag = "[object BigInt64Array]";
var float32ArrayTag = "[object Float32Array]";
var float64ArrayTag = "[object Float64Array]";

// node_modules/storybook/dist/_browser-chunks/chunk-AIOS4NGK.js
function mapValues(object, getNewValue) {
  let result = {}, keys = Object.keys(object);
  for (let i = 0; i < keys.length; i++) {
    let key = keys[i], value = object[key];
    result[key] = getNewValue(value, key, object);
  }
  return result;
}
function isUnsafeProperty(key) {
  return key === "__proto__";
}
function mergeWith(target, source, merge2) {
  let sourceKeys = Object.keys(source);
  for (let i = 0; i < sourceKeys.length; i++) {
    let key = sourceKeys[i];
    if (isUnsafeProperty(key))
      continue;
    let sourceValue = source[key], targetValue = target[key], merged = merge2(targetValue, sourceValue, key, target, source);
    merged !== void 0 ? target[key] = merged : Array.isArray(sourceValue) ? Array.isArray(targetValue) ? target[key] = mergeWith(targetValue, sourceValue, merge2) : target[key] = mergeWith([], sourceValue, merge2) : isPlainObject(sourceValue) ? isPlainObject(targetValue) ? target[key] = mergeWith(targetValue, sourceValue, merge2) : target[key] = mergeWith({}, sourceValue, merge2) : (targetValue === void 0 || sourceValue !== void 0) && (target[key] = sourceValue);
  }
  return target;
}
function pick(obj, keys) {
  let result = {};
  for (let i = 0; i < keys.length; i++) {
    let key = keys[i];
    Object.hasOwn(obj, key) && (result[key] = obj[key]);
  }
  return result;
}
function pickBy(obj, shouldPick) {
  let result = {}, keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    let key = keys[i], value = obj[key];
    shouldPick(value, key) && (result[key] = value);
  }
  return result;
}
function clone(obj) {
  if (isPrimitive(obj))
    return obj;
  if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && obj instanceof SharedArrayBuffer)
    return obj.slice(0);
  let prototype = Object.getPrototypeOf(obj), Constructor = prototype.constructor;
  if (obj instanceof Date || obj instanceof Map || obj instanceof Set)
    return new Constructor(obj);
  if (obj instanceof RegExp) {
    let newRegExp = new Constructor(obj);
    return newRegExp.lastIndex = obj.lastIndex, newRegExp;
  }
  if (obj instanceof DataView)
    return new Constructor(obj.buffer.slice(0));
  if (obj instanceof Error) {
    let newError = new Constructor(obj.message);
    return newError.stack = obj.stack, newError.name = obj.name, newError.cause = obj.cause, newError;
  }
  if (typeof File < "u" && obj instanceof File)
    return new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });
  if (typeof obj == "object") {
    let newObject = Object.create(prototype);
    return Object.assign(newObject, obj);
  }
  return obj;
}
var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
function toMerged(target, source) {
  return mergeWith(clone(target), source, function mergeRecursively(targetValue, sourceValue) {
    if (Array.isArray(sourceValue))
      return Array.isArray(targetValue) ? mergeWith(clone(targetValue), sourceValue, mergeRecursively) : mergeWith([], sourceValue, mergeRecursively);
    if (isPlainObject(sourceValue))
      return isPlainObject(targetValue) ? mergeWith(clone(targetValue), sourceValue, mergeRecursively) : mergeWith({}, sourceValue, mergeRecursively);
  });
}

// node_modules/storybook/dist/_browser-chunks/chunk-VYJQ7RU5.js
var require_dist = __commonJS({
  "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(exports, module) {
    (function(global, factory) {
      typeof exports == "object" && typeof module < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis < "u" ? globalThis : global || self, factory(global.jtpp = {}));
    })(exports, (function(exports2) {
      "use strict";
      function tokenToString(token) {
        return token.text !== void 0 && token.text !== "" ? `'${token.type}' with value '${token.text}'` : `'${token.type}'`;
      }
      class NoParsletFoundError extends Error {
        constructor(token) {
          super(`No parslet found for token: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, NoParsletFoundError.prototype);
        }
        getToken() {
          return this.token;
        }
      }
      class EarlyEndOfParseError extends Error {
        constructor(token) {
          super(`The parsing ended early. The next token was: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);
        }
        getToken() {
          return this.token;
        }
      }
      class UnexpectedTypeError extends Error {
        constructor(result, message) {
          let error = `Unexpected type: '${result.type}'.`;
          message !== void 0 && (error += ` Message: ${message}`), super(error), Object.setPrototypeOf(this, UnexpectedTypeError.prototype);
        }
      }
      function makePunctuationRule(type) {
        return (text) => text.startsWith(type) ? { type, text: type } : null;
      }
      function getQuoted(text) {
        let position = 0, char, mark = text[0], escaped = false;
        if (mark !== "'" && mark !== '"')
          return null;
        for (; position < text.length; ) {
          if (position++, char = text[position], !escaped && char === mark) {
            position++;
            break;
          }
          escaped = !escaped && char === "\\";
        }
        if (char !== mark)
          throw new Error("Unterminated String");
        return text.slice(0, position);
      }
      let identifierStartRegex = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), identifierContinueRegex = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      function getIdentifier(text) {
        let char = text[0];
        if (!identifierStartRegex.test(char))
          return null;
        let position = 1;
        do {
          if (char = text[position], !identifierContinueRegex.test(char))
            break;
          position++;
        } while (position < text.length);
        return text.slice(0, position);
      }
      let numberRegex = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function getNumber(text) {
        var _a, _b;
        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
      }
      let identifierRule = (text) => {
        let value = getIdentifier(text);
        return value == null ? null : {
          type: "Identifier",
          text: value
        };
      };
      function makeKeyWordRule(type) {
        return (text) => {
          if (!text.startsWith(type))
            return null;
          let prepends = text[type.length];
          return prepends !== void 0 && identifierContinueRegex.test(prepends) ? null : {
            type,
            text: type
          };
        };
      }
      let stringValueRule = (text) => {
        let value = getQuoted(text);
        return value == null ? null : {
          type: "StringValue",
          text: value
        };
      }, eofRule = (text) => text.length > 0 ? null : {
        type: "EOF",
        text: ""
      }, numberRule = (text) => {
        let value = getNumber(text);
        return value === null ? null : {
          type: "Number",
          text: value
        };
      }, rules = [
        eofRule,
        makePunctuationRule("=>"),
        makePunctuationRule("("),
        makePunctuationRule(")"),
        makePunctuationRule("{"),
        makePunctuationRule("}"),
        makePunctuationRule("["),
        makePunctuationRule("]"),
        makePunctuationRule("|"),
        makePunctuationRule("&"),
        makePunctuationRule("<"),
        makePunctuationRule(">"),
        makePunctuationRule(","),
        makePunctuationRule(";"),
        makePunctuationRule("*"),
        makePunctuationRule("?"),
        makePunctuationRule("!"),
        makePunctuationRule("="),
        makePunctuationRule(":"),
        makePunctuationRule("..."),
        makePunctuationRule("."),
        makePunctuationRule("#"),
        makePunctuationRule("~"),
        makePunctuationRule("/"),
        makePunctuationRule("@"),
        makeKeyWordRule("undefined"),
        makeKeyWordRule("null"),
        makeKeyWordRule("function"),
        makeKeyWordRule("this"),
        makeKeyWordRule("new"),
        makeKeyWordRule("module"),
        makeKeyWordRule("event"),
        makeKeyWordRule("extends"),
        makeKeyWordRule("external"),
        makeKeyWordRule("infer"),
        makeKeyWordRule("typeof"),
        makeKeyWordRule("keyof"),
        makeKeyWordRule("readonly"),
        makeKeyWordRule("import"),
        makeKeyWordRule("is"),
        makeKeyWordRule("in"),
        makeKeyWordRule("asserts"),
        numberRule,
        identifierRule,
        stringValueRule
      ], breakingWhitespaceRegex = /^\s*\n\s*/;
      class Lexer {
        static create(text) {
          let current = this.read(text);
          text = current.text;
          let next = this.read(text);
          return text = next.text, new Lexer(text, void 0, current.token, next.token);
        }
        constructor(text, previous, current, next) {
          this.text = "", this.text = text, this.previous = previous, this.current = current, this.next = next;
        }
        static read(text, startOfLine = false) {
          startOfLine = startOfLine || breakingWhitespaceRegex.test(text), text = text.trim();
          for (let rule of rules) {
            let partial = rule(text);
            if (partial !== null) {
              let token = Object.assign(Object.assign({}, partial), { startOfLine });
              return text = text.slice(token.text.length), { text, token };
            }
          }
          throw new Error("Unexpected Token " + text);
        }
        advance() {
          let next = Lexer.read(this.text);
          return new Lexer(next.text, this.current, this.next, next.token);
        }
      }
      function assertRootResult(result) {
        if (result === void 0)
          throw new Error("Unexpected undefined");
        if (result.type === "JsdocTypeKeyValue" || result.type === "JsdocTypeParameterList" || result.type === "JsdocTypeProperty" || result.type === "JsdocTypeReadonlyProperty" || result.type === "JsdocTypeObjectField" || result.type === "JsdocTypeJsdocObjectField" || result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType" || result.type === "JsdocTypeTypeParameter")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertPlainKeyValueOrRootResult(result) {
        return result.type === "JsdocTypeKeyValue" ? assertPlainKeyValueResult(result) : assertRootResult(result);
      }
      function assertPlainKeyValueOrNameResult(result) {
        return result.type === "JsdocTypeName" ? result : assertPlainKeyValueResult(result);
      }
      function assertPlainKeyValueResult(result) {
        if (result.type !== "JsdocTypeKeyValue")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertNumberOrVariadicNameResult(result) {
        var _a;
        if (result.type === "JsdocTypeVariadic") {
          if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === "JsdocTypeName")
            return result;
          throw new UnexpectedTypeError(result);
        }
        if (result.type !== "JsdocTypeNumber" && result.type !== "JsdocTypeName")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertArrayOrTupleResult(result) {
        if (result.type === "JsdocTypeTuple" || result.type === "JsdocTypeGeneric" && result.meta.brackets === "square")
          return result;
        throw new UnexpectedTypeError(result);
      }
      function isSquaredProperty(result) {
        return result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType";
      }
      var Precedence;
      (function(Precedence2) {
        Precedence2[Precedence2.ALL = 0] = "ALL", Precedence2[Precedence2.PARAMETER_LIST = 1] = "PARAMETER_LIST", Precedence2[Precedence2.OBJECT = 2] = "OBJECT", Precedence2[Precedence2.KEY_VALUE = 3] = "KEY_VALUE", Precedence2[Precedence2.INDEX_BRACKETS = 4] = "INDEX_BRACKETS", Precedence2[Precedence2.UNION = 5] = "UNION", Precedence2[Precedence2.INTERSECTION = 6] = "INTERSECTION", Precedence2[Precedence2.PREFIX = 7] = "PREFIX", Precedence2[Precedence2.INFIX = 8] = "INFIX", Precedence2[Precedence2.TUPLE = 9] = "TUPLE", Precedence2[Precedence2.SYMBOL = 10] = "SYMBOL", Precedence2[Precedence2.OPTIONAL = 11] = "OPTIONAL", Precedence2[Precedence2.NULLABLE = 12] = "NULLABLE", Precedence2[Precedence2.KEY_OF_TYPE_OF = 13] = "KEY_OF_TYPE_OF", Precedence2[Precedence2.FUNCTION = 14] = "FUNCTION", Precedence2[Precedence2.ARROW = 15] = "ARROW", Precedence2[Precedence2.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", Precedence2[Precedence2.GENERIC = 17] = "GENERIC", Precedence2[Precedence2.NAME_PATH = 18] = "NAME_PATH", Precedence2[Precedence2.PARENTHESIS = 19] = "PARENTHESIS", Precedence2[Precedence2.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
      })(Precedence || (Precedence = {}));
      class Parser {
        constructor(grammar, textOrLexer, baseParser) {
          this.grammar = grammar, typeof textOrLexer == "string" ? this._lexer = Lexer.create(textOrLexer) : this._lexer = textOrLexer, this.baseParser = baseParser;
        }
        get lexer() {
          return this._lexer;
        }
        /**
         * Parses a given string and throws an error if the parse ended before the end of the string.
         */
        parse() {
          let result = this.parseType(Precedence.ALL);
          if (this.lexer.current.type !== "EOF")
            throw new EarlyEndOfParseError(this.lexer.current);
          return result;
        }
        /**
         * Parses with the current lexer and asserts that the result is a {@link RootResult}.
         */
        parseType(precedence) {
          return assertRootResult(this.parseIntermediateType(precedence));
        }
        /**
         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
         * to parse the state in the infix step.
         */
        parseIntermediateType(precedence) {
          let result = this.tryParslets(null, precedence);
          if (result === null)
            throw new NoParsletFoundError(this.lexer.current);
          return this.parseInfixIntermediateType(result, precedence);
        }
        /**
         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
         * a result.
         */
        parseInfixIntermediateType(left, precedence) {
          let result = this.tryParslets(left, precedence);
          for (; result !== null; )
            left = result, result = this.tryParslets(left, precedence);
          return left;
        }
        /**
         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
         */
        tryParslets(left, precedence) {
          for (let parslet of this.grammar) {
            let result = parslet(this, precedence, left);
            if (result !== null)
              return result;
          }
          return null;
        }
        /**
         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
         * advanced.
         */
        consume(types) {
          return Array.isArray(types) || (types = [types]), types.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), true) : false;
        }
        acceptLexerState(parser) {
          this._lexer = parser.lexer;
        }
      }
      function isQuestionMarkUnknownType(next) {
        return next === "}" || next === "EOF" || next === "|" || next === "," || next === ")" || next === ">";
      }
      let nullableParslet = (parser, precedence, left) => {
        let type = parser.lexer.current.type, next = parser.lexer.next.type;
        return left == null && type === "?" && !isQuestionMarkUnknownType(next) || left != null && type === "?" ? (parser.consume("?"), left == null ? {
          type: "JsdocTypeNullable",
          element: parser.parseType(Precedence.NULLABLE),
          meta: {
            position: "prefix"
          }
        } : {
          type: "JsdocTypeNullable",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        }) : null;
      };
      function composeParslet(options) {
        let parslet = (parser, curPrecedence, left) => {
          let type = parser.lexer.current.type, next = parser.lexer.next.type;
          if (left === null) {
            if ("parsePrefix" in options && options.accept(type, next))
              return options.parsePrefix(parser);
          } else if ("parseInfix" in options && options.precedence > curPrecedence && options.accept(type, next))
            return options.parseInfix(parser, left);
          return null;
        };
        return Object.defineProperty(parslet, "name", {
          value: options.name
        }), parslet;
      }
      let optionalParslet = composeParslet({
        name: "optionalParslet",
        accept: (type) => type === "=",
        precedence: Precedence.OPTIONAL,
        parsePrefix: (parser) => (parser.consume("="), {
          type: "JsdocTypeOptional",
          element: parser.parseType(Precedence.OPTIONAL),
          meta: {
            position: "prefix"
          }
        }),
        parseInfix: (parser, left) => (parser.consume("="), {
          type: "JsdocTypeOptional",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        })
      }), numberParslet = composeParslet({
        name: "numberParslet",
        accept: (type) => type === "Number",
        parsePrefix: (parser) => {
          let value = parseFloat(parser.lexer.current.text);
          return parser.consume("Number"), {
            type: "JsdocTypeNumber",
            value
          };
        }
      }), parenthesisParslet = composeParslet({
        name: "parenthesisParslet",
        accept: (type) => type === "(",
        parsePrefix: (parser) => {
          if (parser.consume("("), parser.consume(")"))
            return {
              type: "JsdocTypeParameterList",
              elements: []
            };
          let result = parser.parseIntermediateType(Precedence.ALL);
          if (!parser.consume(")"))
            throw new Error("Unterminated parenthesis");
          return result.type === "JsdocTypeParameterList" ? result : result.type === "JsdocTypeKeyValue" ? {
            type: "JsdocTypeParameterList",
            elements: [result]
          } : {
            type: "JsdocTypeParenthesis",
            element: assertRootResult(result)
          };
        }
      }), specialTypesParslet = composeParslet({
        name: "specialTypesParslet",
        accept: (type, next) => type === "?" && isQuestionMarkUnknownType(next) || type === "null" || type === "undefined" || type === "*",
        parsePrefix: (parser) => {
          if (parser.consume("null"))
            return {
              type: "JsdocTypeNull"
            };
          if (parser.consume("undefined"))
            return {
              type: "JsdocTypeUndefined"
            };
          if (parser.consume("*"))
            return {
              type: "JsdocTypeAny"
            };
          if (parser.consume("?"))
            return {
              type: "JsdocTypeUnknown"
            };
          throw new Error("Unacceptable token: " + parser.lexer.current.text);
        }
      }), notNullableParslet = composeParslet({
        name: "notNullableParslet",
        accept: (type) => type === "!",
        precedence: Precedence.NULLABLE,
        parsePrefix: (parser) => (parser.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: parser.parseType(Precedence.NULLABLE),
          meta: {
            position: "prefix"
          }
        }),
        parseInfix: (parser, left) => (parser.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        })
      });
      function createParameterListParslet({ allowTrailingComma }) {
        return composeParslet({
          name: "parameterListParslet",
          accept: (type) => type === ",",
          precedence: Precedence.PARAMETER_LIST,
          parseInfix: (parser, left) => {
            let elements = [
              assertPlainKeyValueOrRootResult(left)
            ];
            parser.consume(",");
            do
              try {
                let next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);
                elements.push(assertPlainKeyValueOrRootResult(next));
              } catch (e) {
                if (e instanceof NoParsletFoundError)
                  break;
                throw e;
              }
            while (parser.consume(","));
            if (elements.length > 0 && elements.slice(0, -1).some((e) => e.type === "JsdocTypeVariadic"))
              throw new Error("Only the last parameter may be a rest parameter");
            return {
              type: "JsdocTypeParameterList",
              elements
            };
          }
        });
      }
      let genericParslet = composeParslet({
        name: "genericParslet",
        accept: (type, next) => type === "<" || type === "." && next === "<",
        precedence: Precedence.GENERIC,
        parseInfix: (parser, left) => {
          let dot = parser.consume(".");
          parser.consume("<");
          let objects = [], infer = false;
          if (parser.consume("infer")) {
            infer = true;
            let left2 = parser.parseIntermediateType(Precedence.SYMBOL);
            if (left2.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left2, "A typescript asserts always has to have a name on the left side.");
            objects.push(left2);
          } else
            do
              objects.push(parser.parseType(Precedence.PARAMETER_LIST));
            while (parser.consume(","));
          if (!parser.consume(">"))
            throw new Error("Unterminated generic parameter list");
          return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: assertRootResult(left), elements: objects }, infer ? { infer: true } : {}), { meta: {
            brackets: "angle",
            dot
          } });
        }
      }), unionParslet = composeParslet({
        name: "unionParslet",
        accept: (type) => type === "|",
        precedence: Precedence.UNION,
        parseInfix: (parser, left) => {
          parser.consume("|");
          let elements = [];
          do
            elements.push(parser.parseType(Precedence.UNION));
          while (parser.consume("|"));
          return {
            type: "JsdocTypeUnion",
            elements: [assertRootResult(left), ...elements]
          };
        }
      }), baseGrammar = [
        nullableParslet,
        optionalParslet,
        numberParslet,
        parenthesisParslet,
        specialTypesParslet,
        notNullableParslet,
        createParameterListParslet({
          allowTrailingComma: true
        }),
        genericParslet,
        unionParslet,
        optionalParslet
      ];
      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {
        return function(parser, precedence, left) {
          if (left == null || precedence >= Precedence.NAME_PATH)
            return null;
          let type = parser.lexer.current.type, next = parser.lexer.next.type;
          if (!(type === "." && next !== "<" || type === "[" && (allowSquareBracketsOnAnyType || left.type === "JsdocTypeName") || allowJsdocNamePaths && (type === "~" || type === "#")))
            return null;
          let pathType, brackets = false;
          parser.consume(".") ? pathType = "property" : parser.consume("[") ? (pathType = "property-brackets", brackets = true) : parser.consume("~") ? pathType = "inner" : (parser.consume("#"), pathType = "instance");
          let pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser, parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);
          parser.acceptLexerState(pathParser);
          let right;
          switch (parsed.type) {
            case "JsdocTypeName":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeNumber":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value.toString(10),
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeStringValue":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: parsed.meta.quote
                }
              };
              break;
            case "JsdocTypeSpecialNamePath":
              if (parsed.specialType === "event")
                right = parsed;
              else
                throw new UnexpectedTypeError(parsed, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
              break;
            default:
              throw new UnexpectedTypeError(parsed, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
          }
          if (brackets && !parser.consume("]")) {
            let token = parser.lexer.current;
            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);
          }
          return {
            type: "JsdocTypeNamePath",
            left: assertRootResult(left),
            right,
            pathType
          };
        };
      }
      function createNameParslet({ allowedAdditionalTokens }) {
        return composeParslet({
          name: "nameParslet",
          accept: (type) => type === "Identifier" || type === "this" || type === "new" || allowedAdditionalTokens.includes(type),
          parsePrefix: (parser) => {
            let { type, text } = parser.lexer.current;
            return parser.consume(type), {
              type: "JsdocTypeName",
              value: text
            };
          }
        });
      }
      let stringValueParslet = composeParslet({
        name: "stringValueParslet",
        accept: (type) => type === "StringValue",
        parsePrefix: (parser) => {
          let text = parser.lexer.current.text;
          return parser.consume("StringValue"), {
            type: "JsdocTypeStringValue",
            value: text.slice(1, -1),
            meta: {
              quote: text[0] === "'" ? "single" : "double"
            }
          };
        }
      });
      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {
        return composeParslet({
          name: "specialNamePathParslet",
          accept: (type) => allowedTypes.includes(type),
          parsePrefix: (parser) => {
            let type = parser.lexer.current.type;
            if (parser.consume(type), !parser.consume(":"))
              return {
                type: "JsdocTypeName",
                value: type
              };
            let result, token = parser.lexer.current;
            if (parser.consume("StringValue"))
              result = {
                type: "JsdocTypeSpecialNamePath",
                value: token.text.slice(1, -1),
                specialType: type,
                meta: {
                  quote: token.text[0] === "'" ? "single" : "double"
                }
              };
            else {
              let value = "", allowed = ["Identifier", "@", "/"];
              for (; allowed.some((type2) => parser.consume(type2)); )
                value += token.text, token = parser.lexer.current;
              result = {
                type: "JsdocTypeSpecialNamePath",
                value,
                specialType: type,
                meta: {
                  quote: void 0
                }
              };
            }
            let moduleParser = new Parser(pathGrammar2, parser.lexer, parser), moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);
            return parser.acceptLexerState(moduleParser), assertRootResult(moduleResult);
          }
        });
      }
      let basePathGrammar = [
        createNameParslet({
          allowedAdditionalTokens: ["external", "module"]
        }),
        stringValueParslet,
        numberParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar: null
        })
      ], pathGrammar = [
        ...basePathGrammar,
        createSpecialNamePathParslet({
          allowedTypes: ["event"],
          pathGrammar: basePathGrammar
        })
      ];
      function getParameters(value) {
        let parameters2;
        if (value.type === "JsdocTypeParameterList")
          parameters2 = value.elements;
        else if (value.type === "JsdocTypeParenthesis")
          parameters2 = [value.element];
        else
          throw new UnexpectedTypeError(value);
        return parameters2.map((p) => assertPlainKeyValueOrRootResult(p));
      }
      function getUnnamedParameters(value) {
        let parameters2 = getParameters(value);
        if (parameters2.some((p) => p.type === "JsdocTypeKeyValue"))
          throw new Error("No parameter should be named");
        return parameters2;
      }
      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {
        return composeParslet({
          name: "functionParslet",
          accept: (type, next) => type === "function" || allowNewAsFunctionKeyword && type === "new" && next === "(",
          parsePrefix: (parser) => {
            let newKeyword = parser.consume("new");
            parser.consume("function");
            let hasParenthesis = parser.lexer.current.type === "(";
            if (!hasParenthesis) {
              if (!allowWithoutParenthesis)
                throw new Error("function is missing parameter list");
              return {
                type: "JsdocTypeName",
                value: "function"
              };
            }
            let result = {
              type: "JsdocTypeFunction",
              parameters: [],
              arrow: false,
              constructor: newKeyword,
              parenthesis: hasParenthesis
            }, value = parser.parseIntermediateType(Precedence.FUNCTION);
            if (allowNamedParameters === void 0)
              result.parameters = getUnnamedParameters(value);
            else {
              if (newKeyword && value.type === "JsdocTypeFunction" && value.arrow)
                return result = value, result.constructor = true, result;
              result.parameters = getParameters(value);
              for (let p of result.parameters)
                if (p.type === "JsdocTypeKeyValue" && !allowNamedParameters.includes(p.key))
                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(", ")} but got ${p.type}`);
            }
            if (parser.consume(":"))
              result.returnType = parser.parseType(Precedence.PREFIX);
            else if (!allowNoReturnType)
              throw new Error("function is missing return type");
            return result;
          }
        });
      }
      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {
        return composeParslet({
          name: "variadicParslet",
          accept: (type) => type === "...",
          precedence: Precedence.PREFIX,
          parsePrefix: (parser) => {
            parser.consume("...");
            let brackets = allowEnclosingBrackets && parser.consume("[");
            try {
              let element = parser.parseType(Precedence.PREFIX);
              if (brackets && !parser.consume("]"))
                throw new Error("Unterminated variadic type. Missing ']'");
              return {
                type: "JsdocTypeVariadic",
                element: assertRootResult(element),
                meta: {
                  position: "prefix",
                  squareBrackets: brackets
                }
              };
            } catch (e) {
              if (e instanceof NoParsletFoundError) {
                if (brackets)
                  throw new Error("Empty square brackets for variadic are not allowed.");
                return {
                  type: "JsdocTypeVariadic",
                  meta: {
                    position: void 0,
                    squareBrackets: false
                  }
                };
              } else
                throw e;
            }
          },
          parseInfix: allowPostfix ? (parser, left) => (parser.consume("..."), {
            type: "JsdocTypeVariadic",
            element: assertRootResult(left),
            meta: {
              position: "suffix",
              squareBrackets: false
            }
          }) : void 0
        });
      }
      let symbolParslet = composeParslet({
        name: "symbolParslet",
        accept: (type) => type === "(",
        precedence: Precedence.SYMBOL,
        parseInfix: (parser, left) => {
          if (left.type !== "JsdocTypeName")
            throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
          parser.consume("(");
          let result = {
            type: "JsdocTypeSymbol",
            value: left.value
          };
          if (!parser.consume(")")) {
            let next = parser.parseIntermediateType(Precedence.SYMBOL);
            if (result.element = assertNumberOrVariadicNameResult(next), !parser.consume(")"))
              throw new Error("Symbol does not end after value");
          }
          return result;
        }
      }), arrayBracketsParslet = composeParslet({
        name: "arrayBracketsParslet",
        precedence: Precedence.ARRAY_BRACKETS,
        accept: (type, next) => type === "[" && next === "]",
        parseInfix: (parser, left) => (parser.consume("["), parser.consume("]"), {
          type: "JsdocTypeGeneric",
          left: {
            type: "JsdocTypeName",
            value: "Array"
          },
          elements: [
            assertRootResult(left)
          ],
          meta: {
            brackets: "square",
            dot: false
          }
        })
      });
      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {
        return composeParslet({
          name: "objectParslet",
          accept: (type) => type === "{",
          parsePrefix: (parser) => {
            parser.consume("{");
            let result = {
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: []
            };
            if (!parser.consume("}")) {
              let separator, fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);
              for (; ; ) {
                fieldParser.acceptLexerState(parser);
                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);
                parser.acceptLexerState(fieldParser), field === void 0 && allowKeyTypes && (field = parser.parseIntermediateType(Precedence.OBJECT));
                let optional = false;
                if (field.type === "JsdocTypeNullable" && (optional = true, field = field.element), field.type === "JsdocTypeNumber" || field.type === "JsdocTypeName" || field.type === "JsdocTypeStringValue") {
                  let quote2;
                  field.type === "JsdocTypeStringValue" && (quote2 = field.meta.quote), result.elements.push({
                    type: "JsdocTypeObjectField",
                    key: field.value.toString(),
                    right: void 0,
                    optional,
                    readonly: false,
                    meta: {
                      quote: quote2
                    }
                  });
                } else if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField")
                  result.elements.push(field);
                else
                  throw new UnexpectedTypeError(field);
                if (parser.lexer.current.startOfLine)
                  separator = "linebreak", parser.consume(",") || parser.consume(";");
                else if (parser.consume(","))
                  separator = "comma";
                else if (parser.consume(";"))
                  separator = "semicolon";
                else
                  break;
                if (parser.lexer.current.type === "}")
                  break;
              }
              if (result.meta.separator = separator ?? "comma", separator === "linebreak" && (result.meta.propertyIndent = "  "), !parser.consume("}"))
                throw new Error("Unterminated record type. Missing '}'");
            }
            return result;
          }
        });
      }
      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {
        return composeParslet({
          name: "objectFieldParslet",
          precedence: Precedence.KEY_VALUE,
          accept: (type) => type === ":",
          parseInfix: (parser, left) => {
            var _a;
            let optional = false, readonlyProperty = false;
            allowOptional && left.type === "JsdocTypeNullable" && (optional = true, left = left.element), allowReadonly && left.type === "JsdocTypeReadonlyProperty" && (readonlyProperty = true, left = left.element);
            let parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;
            if (parentParser.acceptLexerState(parser), left.type === "JsdocTypeNumber" || left.type === "JsdocTypeName" || left.type === "JsdocTypeStringValue" || isSquaredProperty(left)) {
              if (isSquaredProperty(left) && !allowSquaredProperties)
                throw new UnexpectedTypeError(left);
              parentParser.consume(":");
              let quote2;
              left.type === "JsdocTypeStringValue" && (quote2 = left.meta.quote);
              let right = parentParser.parseType(Precedence.KEY_VALUE);
              return parser.acceptLexerState(parentParser), {
                type: "JsdocTypeObjectField",
                key: isSquaredProperty(left) ? left : left.value.toString(),
                right,
                optional,
                readonly: readonlyProperty,
                meta: {
                  quote: quote2
                }
              };
            } else {
              if (!allowKeyTypes)
                throw new UnexpectedTypeError(left);
              parentParser.consume(":");
              let right = parentParser.parseType(Precedence.KEY_VALUE);
              return parser.acceptLexerState(parentParser), {
                type: "JsdocTypeJsdocObjectField",
                left: assertRootResult(left),
                right
              };
            }
          }
        });
      }
      function createKeyValueParslet({ allowOptional, allowVariadic }) {
        return composeParslet({
          name: "keyValueParslet",
          precedence: Precedence.KEY_VALUE,
          accept: (type) => type === ":",
          parseInfix: (parser, left) => {
            let optional = false, variadic = false;
            if (allowOptional && left.type === "JsdocTypeNullable" && (optional = true, left = left.element), allowVariadic && left.type === "JsdocTypeVariadic" && left.element !== void 0 && (variadic = true, left = left.element), left.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left);
            parser.consume(":");
            let right = parser.parseType(Precedence.KEY_VALUE);
            return {
              type: "JsdocTypeKeyValue",
              key: left.value,
              right,
              optional,
              variadic
            };
          }
        });
      }
      let jsdocBaseGrammar = [
        ...baseGrammar,
        createFunctionParslet({
          allowWithoutParenthesis: true,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: true,
          allowNewAsFunctionKeyword: false
        }),
        stringValueParslet,
        createSpecialNamePathParslet({
          allowedTypes: ["module", "external", "event"],
          pathGrammar
        }),
        createVariadicParslet({
          allowEnclosingBrackets: true,
          allowPostfix: true
        }),
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        symbolParslet,
        arrayBracketsParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar
        })
      ], jsdocGrammar = [
        ...jsdocBaseGrammar,
        createObjectParslet({
          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
          // we leave out the object type deliberately
          objectFieldGrammar: [
            createNameParslet({
              allowedAdditionalTokens: ["typeof", "module", "in"]
            }),
            createObjectFieldParslet({
              allowSquaredProperties: false,
              allowKeyTypes: true,
              allowOptional: false,
              allowReadonly: false
            }),
            ...jsdocBaseGrammar
          ],
          allowKeyTypes: true
        }),
        createKeyValueParslet({
          allowOptional: true,
          allowVariadic: true
        })
      ], typeOfParslet = composeParslet({
        name: "typeOfParslet",
        accept: (type) => type === "typeof",
        parsePrefix: (parser) => (parser.consume("typeof"), {
          type: "JsdocTypeTypeof",
          element: parser.parseType(Precedence.KEY_OF_TYPE_OF)
        })
      }), objectFieldGrammar$1 = [
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: false,
          allowKeyTypes: false,
          allowOptional: false,
          allowReadonly: false
        })
      ], closureGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: false,
          objectFieldGrammar: objectFieldGrammar$1
        }),
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        typeOfParslet,
        createFunctionParslet({
          allowWithoutParenthesis: false,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: true,
          allowNewAsFunctionKeyword: false
        }),
        createVariadicParslet({
          allowEnclosingBrackets: false,
          allowPostfix: false
        }),
        // additional name parslet is needed for some special cases
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar
        }),
        createKeyValueParslet({
          allowOptional: false,
          allowVariadic: false
        }),
        symbolParslet
      ], assertsParslet = composeParslet({
        name: "assertsParslet",
        accept: (type) => type === "asserts",
        parsePrefix: (parser) => {
          parser.consume("asserts");
          let left = parser.parseIntermediateType(Precedence.SYMBOL);
          if (left.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(left, "A typescript asserts always has to have a name on the left side.");
          return parser.consume("is") ? {
            type: "JsdocTypeAsserts",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          } : {
            type: "JsdocTypeAssertsPlain",
            element: left
          };
        }
      });
      function createTupleParslet({ allowQuestionMark }) {
        return composeParslet({
          name: "tupleParslet",
          accept: (type) => type === "[",
          parsePrefix: (parser) => {
            parser.consume("[");
            let result = {
              type: "JsdocTypeTuple",
              elements: []
            };
            if (parser.consume("]"))
              return result;
            let typeList = parser.parseIntermediateType(Precedence.ALL);
            if (typeList.type === "JsdocTypeParameterList" ? typeList.elements[0].type === "JsdocTypeKeyValue" ? result.elements = typeList.elements.map(assertPlainKeyValueResult) : result.elements = typeList.elements.map(assertRootResult) : typeList.type === "JsdocTypeKeyValue" ? result.elements = [assertPlainKeyValueResult(typeList)] : result.elements = [assertRootResult(typeList)], !parser.consume("]"))
              throw new Error("Unterminated '['");
            if (result.elements.some((e) => e.type === "JsdocTypeUnknown"))
              throw new Error("Question mark in tuple not allowed");
            return result;
          }
        });
      }
      let keyOfParslet = composeParslet({
        name: "keyOfParslet",
        accept: (type) => type === "keyof",
        parsePrefix: (parser) => (parser.consume("keyof"), {
          type: "JsdocTypeKeyof",
          element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
        })
      }), importParslet = composeParslet({
        name: "importParslet",
        accept: (type) => type === "import",
        parsePrefix: (parser) => {
          if (parser.consume("import"), !parser.consume("("))
            throw new Error("Missing parenthesis after import keyword");
          let path = parser.parseType(Precedence.PREFIX);
          if (path.type !== "JsdocTypeStringValue")
            throw new Error("Only string values are allowed as paths for imports");
          if (!parser.consume(")"))
            throw new Error("Missing closing parenthesis after import keyword");
          return {
            type: "JsdocTypeImport",
            element: path
          };
        }
      }), readonlyPropertyParslet = composeParslet({
        name: "readonlyPropertyParslet",
        accept: (type) => type === "readonly",
        parsePrefix: (parser) => (parser.consume("readonly"), {
          type: "JsdocTypeReadonlyProperty",
          element: parser.parseIntermediateType(Precedence.KEY_VALUE)
        })
      }), arrowFunctionParslet = composeParslet({
        name: "arrowFunctionParslet",
        precedence: Precedence.ARROW,
        accept: (type) => type === "=>",
        parseInfix: (parser, left) => (parser.consume("=>"), {
          type: "JsdocTypeFunction",
          parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),
          arrow: true,
          constructor: false,
          parenthesis: true,
          returnType: parser.parseType(Precedence.OBJECT)
        })
      }), genericArrowFunctionParslet = composeParslet({
        name: "genericArrowFunctionParslet",
        accept: (type) => type === "<",
        parsePrefix: (parser) => {
          let typeParameters = [];
          parser.consume("<");
          do {
            let defaultValue, name = parser.parseIntermediateType(Precedence.SYMBOL);
            if (name.type === "JsdocTypeOptional" && (name = name.element, defaultValue = parser.parseType(Precedence.SYMBOL)), name.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(name);
            let constraint;
            parser.consume("extends") && (constraint = parser.parseType(Precedence.SYMBOL), constraint.type === "JsdocTypeOptional" && (constraint = constraint.element, defaultValue = parser.parseType(Precedence.SYMBOL)));
            let typeParameter = {
              type: "JsdocTypeTypeParameter",
              name
            };
            if (constraint !== void 0 && (typeParameter.constraint = constraint), defaultValue !== void 0 && (typeParameter.defaultValue = defaultValue), typeParameters.push(typeParameter), parser.consume(">"))
              break;
          } while (parser.consume(","));
          let functionBase = parser.parseIntermediateType(Precedence.SYMBOL);
          return functionBase.typeParameters = typeParameters, functionBase;
        }
      }), intersectionParslet = composeParslet({
        name: "intersectionParslet",
        accept: (type) => type === "&",
        precedence: Precedence.INTERSECTION,
        parseInfix: (parser, left) => {
          parser.consume("&");
          let elements = [];
          do
            elements.push(parser.parseType(Precedence.INTERSECTION));
          while (parser.consume("&"));
          return {
            type: "JsdocTypeIntersection",
            elements: [assertRootResult(left), ...elements]
          };
        }
      }), predicateParslet = composeParslet({
        name: "predicateParslet",
        precedence: Precedence.INFIX,
        accept: (type) => type === "is",
        parseInfix: (parser, left) => {
          if (left.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(left, "A typescript predicate always has to have a name on the left side.");
          return parser.consume("is"), {
            type: "JsdocTypePredicate",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          };
        }
      }), objectSquaredPropertyParslet = composeParslet({
        name: "objectSquareBracketPropertyParslet",
        accept: (type) => type === "[",
        parsePrefix: (parser) => {
          if (parser.baseParser === void 0)
            throw new Error("Only allowed inside object grammar");
          parser.consume("[");
          let key = parser.lexer.current.text;
          parser.consume("Identifier");
          let result;
          if (parser.consume(":")) {
            let parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser), result = {
              type: "JsdocTypeIndexSignature",
              key,
              right: parentParser.parseType(Precedence.INDEX_BRACKETS)
            }, parser.acceptLexerState(parentParser);
          } else if (parser.consume("in")) {
            let parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser), result = {
              type: "JsdocTypeMappedType",
              key,
              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)
            }, parser.acceptLexerState(parentParser);
          } else
            throw new Error("Missing ':' or 'in' inside square bracketed property.");
          if (!parser.consume("]"))
            throw new Error("Unterminated square brackets");
          return result;
        }
      }), readonlyArrayParslet = composeParslet({
        name: "readonlyArrayParslet",
        accept: (type) => type === "readonly",
        parsePrefix: (parser) => (parser.consume("readonly"), {
          type: "JsdocTypeReadonlyArray",
          element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))
        })
      }), conditionalParslet = composeParslet({
        name: "conditionalParslet",
        precedence: Precedence.INFIX,
        accept: (type) => type === "extends",
        parseInfix: (parser, left) => {
          parser.consume("extends");
          let extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element, trueType = parser.parseType(Precedence.INFIX);
          return parser.consume(":"), {
            type: "JsdocTypeConditional",
            checksType: assertRootResult(left),
            extendsType,
            trueType,
            falseType: parser.parseType(Precedence.INFIX)
          };
        }
      }), objectFieldGrammar = [
        readonlyPropertyParslet,
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: true,
          allowKeyTypes: false,
          allowOptional: true,
          allowReadonly: true
        }),
        objectSquaredPropertyParslet
      ], typescriptGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: false,
          objectFieldGrammar
        }),
        readonlyArrayParslet,
        typeOfParslet,
        keyOfParslet,
        importParslet,
        stringValueParslet,
        createFunctionParslet({
          allowWithoutParenthesis: true,
          allowNoReturnType: false,
          allowNamedParameters: ["this", "new", "args"],
          allowNewAsFunctionKeyword: true
        }),
        createTupleParslet({
          allowQuestionMark: false
        }),
        createVariadicParslet({
          allowEnclosingBrackets: false,
          allowPostfix: false
        }),
        assertsParslet,
        conditionalParslet,
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        arrayBracketsParslet,
        arrowFunctionParslet,
        genericArrowFunctionParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: true,
          allowJsdocNamePaths: false,
          pathGrammar
        }),
        intersectionParslet,
        predicateParslet,
        createKeyValueParslet({
          allowVariadic: true,
          allowOptional: true
        })
      ];
      function parse3(expression, mode) {
        switch (mode) {
          case "closure":
            return new Parser(closureGrammar, expression).parse();
          case "jsdoc":
            return new Parser(jsdocGrammar, expression).parse();
          case "typescript":
            return new Parser(typescriptGrammar, expression).parse();
        }
      }
      function tryParse(expression, modes = ["typescript", "closure", "jsdoc"]) {
        let error;
        for (let mode of modes)
          try {
            return parse3(expression, mode);
          } catch (e) {
            error = e;
          }
        throw error;
      }
      function transform(rules2, parseResult) {
        let rule = rules2[parseResult.type];
        if (rule === void 0)
          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);
        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));
      }
      function notAvailableTransform(parseResult) {
        throw new Error("This transform is not available. Are you trying the correct parsing mode?");
      }
      function extractSpecialParams(source) {
        let result = {
          params: []
        };
        for (let param of source.parameters)
          param.type === "JsdocTypeKeyValue" ? param.key === "this" ? result.this = param.right : param.key === "new" ? result.new = param.right : result.params.push(param) : result.params.push(param);
        return result;
      }
      function applyPosition(position, target, value) {
        return position === "prefix" ? value + target : target + value;
      }
      function quote(value, quote2) {
        switch (quote2) {
          case "double":
            return `"${value}"`;
          case "single":
            return `'${value}'`;
          case void 0:
            return value;
        }
      }
      function stringifyRules2() {
        return {
          JsdocTypeParenthesis: (result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : ""})`,
          JsdocTypeKeyof: (result, transform2) => `keyof ${transform2(result.element)}`,
          JsdocTypeFunction: (result, transform2) => {
            var _a;
            if (result.arrow) {
              if (result.returnType === void 0)
                throw new Error("Arrow function needs a return type.");
              let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(", ")) !== null && _a !== void 0 ? _a : ""}>` : ""}(${result.parameters.map(transform2).join(", ")}) => ${transform2(result.returnType)}`;
              return result.constructor && (stringified = "new " + stringified), stringified;
            } else {
              let stringified = result.constructor ? "new" : "function";
              return result.parenthesis && (stringified += `(${result.parameters.map(transform2).join(", ")})`, result.returnType !== void 0 && (stringified += `: ${transform2(result.returnType)}`)), stringified;
            }
          },
          JsdocTypeName: (result) => result.value,
          JsdocTypeTuple: (result, transform2) => `[${result.elements.map(transform2).join(", ")}]`,
          JsdocTypeVariadic: (result, transform2) => result.meta.position === void 0 ? "..." : applyPosition(result.meta.position, transform2(result.element), "..."),
          JsdocTypeNamePath: (result, transform2) => {
            let left = transform2(result.left), right = transform2(result.right);
            switch (result.pathType) {
              case "inner":
                return `${left}~${right}`;
              case "instance":
                return `${left}#${right}`;
              case "property":
                return `${left}.${right}`;
              case "property-brackets":
                return `${left}[${right}]`;
            }
          },
          JsdocTypeStringValue: (result) => quote(result.value, result.meta.quote),
          JsdocTypeAny: () => "*",
          JsdocTypeGeneric: (result, transform2) => {
            if (result.meta.brackets === "square") {
              let element = result.elements[0], transformed = transform2(element);
              return element.type === "JsdocTypeUnion" || element.type === "JsdocTypeIntersection" ? `(${transformed})[]` : `${transformed}[]`;
            } else
              return `${transform2(result.left)}${result.meta.dot ? "." : ""}<${result.infer === true ? "infer " : ""}${result.elements.map(transform2).join(", ")}>`;
          },
          JsdocTypeImport: (result, transform2) => `import(${transform2(result.element)})`,
          JsdocTypeObjectField: (result, transform2) => {
            let text = "";
            return result.readonly && (text += "readonly "), typeof result.key == "string" ? text += quote(result.key, result.meta.quote) : text += transform2(result.key), result.optional && (text += "?"), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
          },
          JsdocTypeJsdocObjectField: (result, transform2) => `${transform2(result.left)}: ${transform2(result.right)}`,
          JsdocTypeKeyValue: (result, transform2) => {
            let text = result.key;
            return result.optional && (text += "?"), result.variadic && (text = "..." + text), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
          },
          JsdocTypeSpecialNamePath: (result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`,
          JsdocTypeNotNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "!"),
          JsdocTypeNull: () => "null",
          JsdocTypeNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "?"),
          JsdocTypeNumber: (result) => result.value.toString(),
          JsdocTypeObject: (result, transform2) => {
            var _a, _b;
            return `{${(result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : "") : "") + result.elements.map(transform2).join(result.meta.separator === "comma" ? ", " : result.meta.separator === "linebreak" ? `
` + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : "") : "; ") + (result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` : "")}}`;
          },
          JsdocTypeOptional: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "="),
          JsdocTypeSymbol: (result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : ""})`,
          JsdocTypeTypeof: (result, transform2) => `typeof ${transform2(result.element)}`,
          JsdocTypeUndefined: () => "undefined",
          JsdocTypeUnion: (result, transform2) => result.elements.map(transform2).join(" | "),
          JsdocTypeUnknown: () => "?",
          JsdocTypeIntersection: (result, transform2) => result.elements.map(transform2).join(" & "),
          JsdocTypeProperty: (result) => quote(result.value, result.meta.quote),
          JsdocTypePredicate: (result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`,
          JsdocTypeIndexSignature: (result, transform2) => `[${result.key}: ${transform2(result.right)}]`,
          JsdocTypeMappedType: (result, transform2) => `[${result.key} in ${transform2(result.right)}]`,
          JsdocTypeAsserts: (result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`,
          JsdocTypeReadonlyArray: (result, transform2) => `readonly ${transform2(result.element)}`,
          JsdocTypeAssertsPlain: (result, transform2) => `asserts ${transform2(result.element)}`,
          JsdocTypeConditional: (result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`,
          JsdocTypeTypeParameter: (result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : ""}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : ""}`
        };
      }
      let storedStringifyRules = stringifyRules2();
      function stringify2(result) {
        return transform(storedStringifyRules, result);
      }
      let reservedWords = [
        "null",
        "true",
        "false",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ];
      function makeName(value) {
        let result = {
          type: "NameExpression",
          name: value
        };
        return reservedWords.includes(value) && (result.reservedWord = true), result;
      }
      let catharsisTransformRules = {
        JsdocTypeOptional: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.optional = true, transformed;
        },
        JsdocTypeNullable: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.nullable = true, transformed;
        },
        JsdocTypeNotNullable: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.nullable = false, transformed;
        },
        JsdocTypeVariadic: (result, transform2) => {
          if (result.element === void 0)
            throw new Error("dots without value are not allowed in catharsis mode");
          let transformed = transform2(result.element);
          return transformed.repeatable = true, transformed;
        },
        JsdocTypeAny: () => ({
          type: "AllLiteral"
        }),
        JsdocTypeNull: () => ({
          type: "NullLiteral"
        }),
        JsdocTypeStringValue: (result) => makeName(quote(result.value, result.meta.quote)),
        JsdocTypeUndefined: () => ({
          type: "UndefinedLiteral"
        }),
        JsdocTypeUnknown: () => ({
          type: "UnknownLiteral"
        }),
        JsdocTypeFunction: (result, transform2) => {
          let params = extractSpecialParams(result), transformed = {
            type: "FunctionType",
            params: params.params.map(transform2)
          };
          return params.this !== void 0 && (transformed.this = transform2(params.this)), params.new !== void 0 && (transformed.new = transform2(params.new)), result.returnType !== void 0 && (transformed.result = transform2(result.returnType)), transformed;
        },
        JsdocTypeGeneric: (result, transform2) => ({
          type: "TypeApplication",
          applications: result.elements.map((o) => transform2(o)),
          expression: transform2(result.left)
        }),
        JsdocTypeSpecialNamePath: (result) => makeName(result.specialType + ":" + quote(result.value, result.meta.quote)),
        JsdocTypeName: (result) => result.value !== "function" ? makeName(result.value) : {
          type: "FunctionType",
          params: []
        },
        JsdocTypeNumber: (result) => makeName(result.value.toString()),
        JsdocTypeObject: (result, transform2) => {
          let transformed = {
            type: "RecordType",
            fields: []
          };
          for (let field of result.elements)
            field.type !== "JsdocTypeObjectField" && field.type !== "JsdocTypeJsdocObjectField" ? transformed.fields.push({
              type: "FieldType",
              key: transform2(field),
              value: void 0
            }) : transformed.fields.push(transform2(field));
          return transformed;
        },
        JsdocTypeObjectField: (result, transform2) => {
          if (typeof result.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          return {
            type: "FieldType",
            key: makeName(quote(result.key, result.meta.quote)),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          };
        },
        JsdocTypeJsdocObjectField: (result, transform2) => ({
          type: "FieldType",
          key: transform2(result.left),
          value: transform2(result.right)
        }),
        JsdocTypeUnion: (result, transform2) => ({
          type: "TypeUnion",
          elements: result.elements.map((e) => transform2(e))
        }),
        JsdocTypeKeyValue: (result, transform2) => ({
          type: "FieldType",
          key: makeName(result.key),
          value: result.right === void 0 ? void 0 : transform2(result.right)
        }),
        JsdocTypeNamePath: (result, transform2) => {
          let leftResult = transform2(result.left), rightValue;
          result.right.type === "JsdocTypeSpecialNamePath" ? rightValue = transform2(result.right).name : rightValue = quote(result.right.value, result.right.meta.quote);
          let joiner = result.pathType === "inner" ? "~" : result.pathType === "instance" ? "#" : ".";
          return makeName(`${leftResult.name}${joiner}${rightValue}`);
        },
        JsdocTypeSymbol: (result) => {
          let value = "", element = result.element, trailingDots = false;
          return element?.type === "JsdocTypeVariadic" && (element.meta.position === "prefix" ? value = "..." : trailingDots = true, element = element.element), element?.type === "JsdocTypeName" ? value += element.value : element?.type === "JsdocTypeNumber" && (value += element.value.toString()), trailingDots && (value += "..."), makeName(`${result.value}(${value})`);
        },
        JsdocTypeParenthesis: (result, transform2) => transform2(assertRootResult(result.element)),
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeImport: notAvailableTransform,
        JsdocTypeKeyof: notAvailableTransform,
        JsdocTypeTuple: notAvailableTransform,
        JsdocTypeTypeof: notAvailableTransform,
        JsdocTypeIntersection: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function catharsisTransform(result) {
        return transform(catharsisTransformRules, result);
      }
      function getQuoteStyle(quote2) {
        switch (quote2) {
          case void 0:
            return "none";
          case "single":
            return "single";
          case "double":
            return "double";
        }
      }
      function getMemberType(type) {
        switch (type) {
          case "inner":
            return "INNER_MEMBER";
          case "instance":
            return "INSTANCE_MEMBER";
          case "property":
            return "MEMBER";
          case "property-brackets":
            return "MEMBER";
        }
      }
      function nestResults(type, results) {
        return results.length === 2 ? {
          type,
          left: results[0],
          right: results[1]
        } : {
          type,
          left: results[0],
          right: nestResults(type, results.slice(1))
        };
      }
      let jtpRules = {
        JsdocTypeOptional: (result, transform2) => ({
          type: "OPTIONAL",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
          }
        }),
        JsdocTypeNullable: (result, transform2) => ({
          type: "NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
          }
        }),
        JsdocTypeNotNullable: (result, transform2) => ({
          type: "NOT_NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
          }
        }),
        JsdocTypeVariadic: (result, transform2) => {
          let transformed = {
            type: "VARIADIC",
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_DOTS" : result.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
            }
          };
          return result.element !== void 0 && (transformed.value = transform2(result.element)), transformed;
        },
        JsdocTypeName: (result) => ({
          type: "NAME",
          name: result.value
        }),
        JsdocTypeTypeof: (result, transform2) => ({
          type: "TYPE_QUERY",
          name: transform2(result.element)
        }),
        JsdocTypeTuple: (result, transform2) => ({
          type: "TUPLE",
          entries: result.elements.map(transform2)
        }),
        JsdocTypeKeyof: (result, transform2) => ({
          type: "KEY_QUERY",
          value: transform2(result.element)
        }),
        JsdocTypeImport: (result) => ({
          type: "IMPORT",
          path: {
            type: "STRING_VALUE",
            quoteStyle: getQuoteStyle(result.element.meta.quote),
            string: result.element.value
          }
        }),
        JsdocTypeUndefined: () => ({
          type: "NAME",
          name: "undefined"
        }),
        JsdocTypeAny: () => ({
          type: "ANY"
        }),
        JsdocTypeFunction: (result, transform2) => {
          let specialParams = extractSpecialParams(result), transformed = {
            type: result.arrow ? "ARROW" : "FUNCTION",
            params: specialParams.params.map((param) => {
              if (param.type === "JsdocTypeKeyValue") {
                if (param.right === void 0)
                  throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                return {
                  type: "NAMED_PARAMETER",
                  name: param.key,
                  typeName: transform2(param.right)
                };
              } else
                return transform2(param);
            }),
            new: null,
            returns: null
          };
          return specialParams.this !== void 0 ? transformed.this = transform2(specialParams.this) : result.arrow || (transformed.this = null), specialParams.new !== void 0 && (transformed.new = transform2(specialParams.new)), result.returnType !== void 0 && (transformed.returns = transform2(result.returnType)), transformed;
        },
        JsdocTypeGeneric: (result, transform2) => {
          let transformed = {
            type: "GENERIC",
            subject: transform2(result.left),
            objects: result.elements.map(transform2),
            meta: {
              syntax: result.meta.brackets === "square" ? "SQUARE_BRACKET" : result.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
            }
          };
          return result.meta.brackets === "square" && result.elements[0].type === "JsdocTypeFunction" && !result.elements[0].parenthesis && (transformed.objects[0] = {
            type: "NAME",
            name: "function"
          }), transformed;
        },
        JsdocTypeObjectField: (result, transform2) => {
          if (typeof result.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          if (result.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: getQuoteStyle(result.meta.quote),
              value: null,
              readonly: false
            };
          let right = transform2(result.right);
          return result.optional && (right = {
            type: "OPTIONAL",
            value: right,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: result.key.toString(),
            quoteStyle: getQuoteStyle(result.meta.quote),
            value: right,
            readonly: false
          };
        },
        JsdocTypeJsdocObjectField: () => {
          throw new Error("Keys may not be typed in jsdoctypeparser.");
        },
        JsdocTypeKeyValue: (result, transform2) => {
          if (result.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: "none",
              value: null,
              readonly: false
            };
          let right = transform2(result.right);
          return result.optional && (right = {
            type: "OPTIONAL",
            value: right,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: result.key,
            quoteStyle: "none",
            value: right,
            readonly: false
          };
        },
        JsdocTypeObject: (result, transform2) => {
          let entries = [];
          for (let field of result.elements)
            (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") && entries.push(transform2(field));
          return {
            type: "RECORD",
            entries
          };
        },
        JsdocTypeSpecialNamePath: (result) => {
          if (result.specialType !== "module")
            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);
          return {
            type: "MODULE",
            value: {
              type: "FILE_PATH",
              quoteStyle: getQuoteStyle(result.meta.quote),
              path: result.value
            }
          };
        },
        JsdocTypeNamePath: (result, transform2) => {
          let hasEventPrefix = false, name, quoteStyle;
          result.right.type === "JsdocTypeSpecialNamePath" && result.right.specialType === "event" ? (hasEventPrefix = true, name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote)) : (name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote));
          let transformed = {
            type: getMemberType(result.pathType),
            owner: transform2(result.left),
            name,
            quoteStyle,
            hasEventPrefix
          };
          if (transformed.owner.type === "MODULE") {
            let tModule = transformed.owner;
            return transformed.owner = transformed.owner.value, tModule.value = transformed, tModule;
          } else
            return transformed;
        },
        JsdocTypeUnion: (result, transform2) => nestResults("UNION", result.elements.map(transform2)),
        JsdocTypeParenthesis: (result, transform2) => ({
          type: "PARENTHESIS",
          value: transform2(assertRootResult(result.element))
        }),
        JsdocTypeNull: () => ({
          type: "NAME",
          name: "null"
        }),
        JsdocTypeUnknown: () => ({
          type: "UNKNOWN"
        }),
        JsdocTypeStringValue: (result) => ({
          type: "STRING_VALUE",
          quoteStyle: getQuoteStyle(result.meta.quote),
          string: result.value
        }),
        JsdocTypeIntersection: (result, transform2) => nestResults("INTERSECTION", result.elements.map(transform2)),
        JsdocTypeNumber: (result) => ({
          type: "NUMBER_VALUE",
          number: result.value.toString()
        }),
        JsdocTypeSymbol: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function jtpTransform(result) {
        return transform(jtpRules, result);
      }
      function identityTransformRules() {
        return {
          JsdocTypeIntersection: (result, transform2) => ({
            type: "JsdocTypeIntersection",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeGeneric: (result, transform2) => ({
            type: "JsdocTypeGeneric",
            left: transform2(result.left),
            elements: result.elements.map(transform2),
            meta: {
              dot: result.meta.dot,
              brackets: result.meta.brackets
            }
          }),
          JsdocTypeNullable: (result) => result,
          JsdocTypeUnion: (result, transform2) => ({
            type: "JsdocTypeUnion",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeUnknown: (result) => result,
          JsdocTypeUndefined: (result) => result,
          JsdocTypeTypeof: (result, transform2) => ({
            type: "JsdocTypeTypeof",
            element: transform2(result.element)
          }),
          JsdocTypeSymbol: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeSymbol",
              value: result.value
            };
            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
          },
          JsdocTypeOptional: (result, transform2) => ({
            type: "JsdocTypeOptional",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }),
          JsdocTypeObject: (result, transform2) => ({
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: result.elements.map(transform2)
          }),
          JsdocTypeNumber: (result) => result,
          JsdocTypeNull: (result) => result,
          JsdocTypeNotNullable: (result, transform2) => ({
            type: "JsdocTypeNotNullable",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }),
          JsdocTypeSpecialNamePath: (result) => result,
          JsdocTypeObjectField: (result, transform2) => ({
            type: "JsdocTypeObjectField",
            key: result.key,
            right: result.right === void 0 ? void 0 : transform2(result.right),
            optional: result.optional,
            readonly: result.readonly,
            meta: result.meta
          }),
          JsdocTypeJsdocObjectField: (result, transform2) => ({
            type: "JsdocTypeJsdocObjectField",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeKeyValue: (result, transform2) => ({
            type: "JsdocTypeKeyValue",
            key: result.key,
            right: result.right === void 0 ? void 0 : transform2(result.right),
            optional: result.optional,
            variadic: result.variadic
          }),
          JsdocTypeImport: (result, transform2) => ({
            type: "JsdocTypeImport",
            element: transform2(result.element)
          }),
          JsdocTypeAny: (result) => result,
          JsdocTypeStringValue: (result) => result,
          JsdocTypeNamePath: (result) => result,
          JsdocTypeVariadic: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeVariadic",
              meta: {
                position: result.meta.position,
                squareBrackets: result.meta.squareBrackets
              }
            };
            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
          },
          JsdocTypeTuple: (result, transform2) => ({
            type: "JsdocTypeTuple",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeName: (result) => result,
          JsdocTypeFunction: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeFunction",
              arrow: result.arrow,
              parameters: result.parameters.map(transform2),
              constructor: result.constructor,
              parenthesis: result.parenthesis
            };
            return result.returnType !== void 0 && (transformed.returnType = transform2(result.returnType)), transformed;
          },
          JsdocTypeKeyof: (result, transform2) => ({
            type: "JsdocTypeKeyof",
            element: transform2(result.element)
          }),
          JsdocTypeParenthesis: (result, transform2) => ({
            type: "JsdocTypeParenthesis",
            element: transform2(result.element)
          }),
          JsdocTypeProperty: (result) => result,
          JsdocTypePredicate: (result, transform2) => ({
            type: "JsdocTypePredicate",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeIndexSignature: (result, transform2) => ({
            type: "JsdocTypeIndexSignature",
            key: result.key,
            right: transform2(result.right)
          }),
          JsdocTypeMappedType: (result, transform2) => ({
            type: "JsdocTypeMappedType",
            key: result.key,
            right: transform2(result.right)
          }),
          JsdocTypeAsserts: (result, transform2) => ({
            type: "JsdocTypeAsserts",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeReadonlyArray: (result, transform2) => ({
            type: "JsdocTypeReadonlyArray",
            element: transform2(result.element)
          }),
          JsdocTypeAssertsPlain: (result, transform2) => ({
            type: "JsdocTypeAssertsPlain",
            element: transform2(result.element)
          }),
          JsdocTypeConditional: (result, transform2) => ({
            type: "JsdocTypeConditional",
            checksType: transform2(result.checksType),
            extendsType: transform2(result.extendsType),
            trueType: transform2(result.trueType),
            falseType: transform2(result.falseType)
          }),
          JsdocTypeTypeParameter: (result, transform2) => ({
            type: "JsdocTypeTypeParameter",
            name: transform2(result.name),
            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,
            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0
          })
        };
      }
      let visitorKeys = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ["parameters", "returnType"],
        JsdocTypeGeneric: ["left", "elements"],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ["right"],
        JsdocTypeIntersection: ["elements"],
        JsdocTypeKeyof: ["element"],
        JsdocTypeKeyValue: ["right"],
        JsdocTypeMappedType: ["right"],
        JsdocTypeName: [],
        JsdocTypeNamePath: ["left", "right"],
        JsdocTypeNotNullable: ["element"],
        JsdocTypeNull: [],
        JsdocTypeNullable: ["element"],
        JsdocTypeNumber: [],
        JsdocTypeObject: ["elements"],
        JsdocTypeObjectField: ["right"],
        JsdocTypeJsdocObjectField: ["left", "right"],
        JsdocTypeOptional: ["element"],
        JsdocTypeParenthesis: ["element"],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ["element"],
        JsdocTypeTuple: ["elements"],
        JsdocTypeTypeof: ["element"],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ["elements"],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ["element"],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ["left", "right"],
        JsdocTypeAsserts: ["left", "right"],
        JsdocTypeReadonlyArray: ["element"],
        JsdocTypeAssertsPlain: ["element"],
        JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
        JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
      };
      function _traverse(node, parentNode, property, onEnter, onLeave) {
        onEnter?.(node, parentNode, property);
        let keysToVisit = visitorKeys[node.type];
        for (let key of keysToVisit) {
          let value = node[key];
          if (value !== void 0)
            if (Array.isArray(value))
              for (let element of value)
                _traverse(element, node, key, onEnter, onLeave);
            else
              _traverse(value, node, key, onEnter, onLeave);
        }
        onLeave?.(node, parentNode, property);
      }
      function traverse(node, onEnter, onLeave) {
        _traverse(node, void 0, void 0, onEnter, onLeave);
      }
      exports2.catharsisTransform = catharsisTransform, exports2.identityTransformRules = identityTransformRules, exports2.jtpTransform = jtpTransform, exports2.parse = parse3, exports2.stringify = stringify2, exports2.stringifyRules = stringifyRules2, exports2.transform = transform, exports2.traverse = traverse, exports2.tryParse = tryParse, exports2.visitorKeys = visitorKeys;
    }));
  }
});
var TypeSystem = ((TypeSystem2) => (TypeSystem2.JAVASCRIPT = "JavaScript", TypeSystem2.FLOW = "Flow", TypeSystem2.TYPESCRIPT = "TypeScript", TypeSystem2.UNKNOWN = "Unknown", TypeSystem2))(TypeSystem || {});
var Markers;
(function(Markers2) {
  Markers2.start = "/**", Markers2.nostart = "/***", Markers2.delim = "*", Markers2.end = "*/";
})(Markers = Markers || (Markers = {}));
function join(tokens) {
  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;
}
function getStringifier() {
  return (block) => block.source.map(({ tokens }) => join(tokens)).join(`
`);
}
var zeroWidth = {
  line: 0,
  start: 0,
  delimiter: 0,
  postDelimiter: 0,
  tag: 0,
  postTag: 0,
  name: 0,
  postName: 0,
  type: 0,
  postType: 0,
  description: 0,
  end: 0,
  lineEnd: 0
};
var fields = Object.keys(zeroWidth);
var stringify = getStringifier();
var import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);
var jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)();
var originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;
jsdocStringifyRules.JsdocTypeAny = () => "any";
jsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;
jsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join("|");
var combineParameters = (...parameterSets) => {
  let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters2) => (Object.entries(parameters2).forEach(([key, value]) => {
    let existing = acc[key];
    Array.isArray(value) || typeof existing > "u" ? acc[key] = value : isPlainObject(value) && isPlainObject(existing) ? mergeKeys[key] = true : typeof value < "u" && (acc[key] = value);
  }), acc), {});
  return Object.keys(mergeKeys).forEach((key) => {
    let mergeValues = definedParametersSets.filter(Boolean).map((p) => p[key]).filter((value) => typeof value < "u");
    mergeValues.every((value) => isPlainObject(value)) ? combined[key] = combineParameters(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];
  }), combined;
};
var enhanceArgTypes = (context) => {
  let {
    component,
    argTypes: userArgTypes,
    parameters: { docs = {} }
  } = context, { extractArgTypes } = docs;
  if (!extractArgTypes || !component)
    return userArgTypes;
  let extractedArgTypes = extractArgTypes(component);
  return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;
};
var ADDON_ID = "storybook/docs";
var PANEL_ID = `${ADDON_ID}/panel`;
var SNIPPET_RENDERED = `${ADDON_ID}/snippet-rendered`;
var SourceType = ((SourceType2) => (SourceType2.AUTO = "auto", SourceType2.CODE = "code", SourceType2.DYNAMIC = "dynamic", SourceType2))(SourceType || {});

// node_modules/storybook/dist/_browser-chunks/chunk-3OXGAGBE.js
var require_string_util = __commonJS({
  "../node_modules/picoquery/lib/string-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeString = encodeString;
    var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase()), noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
    ]);
    function encodeString(str) {
      let len = str.length;
      if (len === 0)
        return "";
      let out = "", lastPos = 0, i = 0;
      outer: for (; i < len; i++) {
        let c = str.charCodeAt(i);
        for (; c < 128; ) {
          if (noEscape[c] !== 1 && (lastPos < i && (out += str.slice(lastPos, i)), lastPos = i + 1, out += hexTable[c]), ++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i && (out += str.slice(lastPos, i)), c < 2048) {
          lastPos = i + 1, out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1, out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        if (++i, i >= len)
          throw new Error("URI malformed");
        let c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1, c = 65536 + ((c & 1023) << 10 | c2), out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return lastPos === 0 ? str : lastPos < len ? out + str.slice(lastPos) : out;
    }
  }
});
var require_shared = __commonJS({
  "../node_modules/picoquery/lib/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOptions = exports.defaultShouldSerializeObject = exports.defaultValueSerializer = void 0;
    var string_util_js_1 = require_string_util(), defaultValueSerializer = (value) => {
      switch (typeof value) {
        case "string":
          return (0, string_util_js_1.encodeString)(value);
        case "bigint":
        case "boolean":
          return "" + value;
        case "number":
          if (Number.isFinite(value))
            return value < 1e21 ? "" + value : (0, string_util_js_1.encodeString)("" + value);
          break;
      }
      return value instanceof Date ? (0, string_util_js_1.encodeString)(value.toISOString()) : "";
    };
    exports.defaultValueSerializer = defaultValueSerializer;
    var defaultShouldSerializeObject = (val) => val instanceof Date;
    exports.defaultShouldSerializeObject = defaultShouldSerializeObject;
    var identityFunc = (v) => v;
    exports.defaultOptions = {
      nesting: true,
      nestingSyntax: "dot",
      arrayRepeat: false,
      arrayRepeatSyntax: "repeat",
      delimiter: 38,
      valueDeserializer: identityFunc,
      valueSerializer: exports.defaultValueSerializer,
      keyDeserializer: identityFunc,
      shouldSerializeObject: exports.defaultShouldSerializeObject
    };
  }
});
var require_object_util = __commonJS({
  "../node_modules/picoquery/lib/object-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDeepObject = getDeepObject;
    exports.stringifyObject = stringifyObject;
    var shared_js_1 = require_shared(), string_util_js_1 = require_string_util();
    function isPrototypeKey(value) {
      return value === "__proto__" || value === "constructor" || value === "prototype";
    }
    function getDeepObject(obj, key, nextKey, forceObject, forceArray) {
      if (isPrototypeKey(key))
        return obj;
      let currObj = obj[key];
      return typeof currObj == "object" && currObj !== null ? currObj : !forceObject && (forceArray || typeof nextKey == "number" || typeof nextKey == "string" && nextKey * 0 === 0 && nextKey.indexOf(".") === -1) ? obj[key] = [] : obj[key] = {};
    }
    var MAX_DEPTH = 20, strBracketPair = "[]", strBracketLeft = "[", strBracketRight = "]", strDot = ".";
    function stringifyObject(obj, options, depth = 0, parentKey, isProbableArray) {
      let { nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, delimiter = shared_js_1.defaultOptions.delimiter, valueSerializer = shared_js_1.defaultOptions.valueSerializer, shouldSerializeObject = shared_js_1.defaultOptions.shouldSerializeObject } = options, strDelimiter = typeof delimiter == "number" ? String.fromCharCode(delimiter) : delimiter, useArrayRepeatKey = isProbableArray === true && arrayRepeat, shouldUseDot = nestingSyntax === "dot" || nestingSyntax === "js" && !isProbableArray;
      if (depth > MAX_DEPTH)
        return "";
      let result = "", firstKey = true, valueIsProbableArray = false;
      for (let key in obj) {
        let value = obj[key];
        if (value === void 0)
          continue;
        let path;
        parentKey ? (path = parentKey, useArrayRepeatKey ? arrayRepeatSyntax === "bracket" && (path += strBracketPair) : shouldUseDot ? (path += strDot, path += key) : (path += strBracketLeft, path += key, path += strBracketRight)) : path = key, firstKey || (result += strDelimiter), typeof value == "object" && value !== null && !shouldSerializeObject(value) ? (valueIsProbableArray = value.pop !== void 0, (nesting || arrayRepeat && valueIsProbableArray) && (result += stringifyObject(value, options, depth + 1, path, valueIsProbableArray))) : (result += (0, string_util_js_1.encodeString)(path), result += "=", result += valueSerializer(value, key)), firstKey && (firstKey = false);
      }
      return result;
    }
  }
});
var require_decode_uri_component = __commonJS({
  "../node_modules/picoquery/lib/decode-uri-component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeURIComponent = decodeURIComponent;
    var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent(uri) {
      let percentPosition = uri.indexOf("%");
      if (percentPosition === -1)
        return uri;
      let length = uri.length, decoded = "", last = 0, codepoint = 0, startOfOctets = percentPosition, state3 = UTF8_ACCEPT;
      for (; percentPosition > -1 && percentPosition < length; ) {
        let high = hexCodeToInt(uri[percentPosition + 1], 4), low = hexCodeToInt(uri[percentPosition + 2], 0), byte = high | low, type = UTF8_DATA[byte];
        if (state3 = UTF8_DATA[256 + state3 + type], codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type], state3 === UTF8_ACCEPT)
          decoded += uri.slice(last, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last = percentPosition + 3, percentPosition = startOfOctets = uri.indexOf("%", last);
        else {
          if (state3 === UTF8_REJECT)
            return null;
          if (percentPosition += 3, percentPosition < length && uri.charCodeAt(percentPosition) === 37)
            continue;
          return null;
        }
      }
      return decoded + uri.slice(last);
    }
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    function hexCodeToInt(c, shift) {
      let i = HEX[c];
      return i === void 0 ? 255 : i << shift;
    }
  }
});
var require_parse = __commonJS({
  "../node_modules/picoquery/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numberValueDeserializer = exports.numberKeyDeserializer = void 0;
    exports.parse = parse;
    var object_util_js_1 = require_object_util(), shared_js_1 = require_shared(), decode_uri_component_js_1 = require_decode_uri_component(), numberKeyDeserializer = (key) => {
      let asNumber = Number(key);
      return Number.isNaN(asNumber) ? key : asNumber;
    };
    exports.numberKeyDeserializer = numberKeyDeserializer;
    var numberValueDeserializer = (value) => {
      let asNumber = Number(value);
      return Number.isNaN(asNumber) ? value : asNumber;
    };
    exports.numberValueDeserializer = numberValueDeserializer;
    var regexPlus = /\+/g, Empty = function() {
    };
    Empty.prototype = /* @__PURE__ */ Object.create(null);
    function computeKeySlice(input, startIndex, endIndex, keyHasPlus, shouldDecodeKey) {
      let chunk = input.substring(startIndex, endIndex);
      return keyHasPlus && (chunk = chunk.replace(regexPlus, " ")), shouldDecodeKey && (chunk = (0, decode_uri_component_js_1.decodeURIComponent)(chunk) || chunk), chunk;
    }
    function parse(input, options) {
      let { valueDeserializer = shared_js_1.defaultOptions.valueDeserializer, keyDeserializer = shared_js_1.defaultOptions.keyDeserializer, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, delimiter = shared_js_1.defaultOptions.delimiter } = options ?? {}, charDelimiter = typeof delimiter == "string" ? delimiter.charCodeAt(0) : delimiter, isJsNestingSyntax = nestingSyntax === "js", result = new Empty();
      if (typeof input != "string")
        return result;
      let inputLength = input.length, value = "", startingIndex = -1, equalityIndex = -1, keySeparatorIndex = -1, currentObj = result, lastKey, currentKey = "", keyChunk = "", shouldDecodeKey = false, shouldDecodeValue = false, keyHasPlus = false, valueHasPlus = false, keyIsDot = false, hasBothKeyValuePair = false, c = 0, arrayRepeatBracketIndex = -1, prevIndex = -1, prevChar = -1;
      for (let i = 0; i < inputLength + 1; i++) {
        if (c = i !== inputLength ? input.charCodeAt(i) : charDelimiter, c === charDelimiter) {
          if (hasBothKeyValuePair = equalityIndex > startingIndex, hasBothKeyValuePair || (equalityIndex = i), keySeparatorIndex !== equalityIndex - 1 && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, arrayRepeatBracketIndex > -1 ? arrayRepeatBracketIndex : equalityIndex, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax && keyIsDot, void 0))), hasBothKeyValuePair || currentKey !== "") {
            hasBothKeyValuePair && (value = input.slice(equalityIndex + 1, i), valueHasPlus && (value = value.replace(regexPlus, " ")), shouldDecodeValue && (value = (0, decode_uri_component_js_1.decodeURIComponent)(value) || value));
            let newValue = valueDeserializer(value, currentKey);
            if (arrayRepeat) {
              let currentValue = currentObj[currentKey];
              currentValue === void 0 ? arrayRepeatBracketIndex > -1 ? currentObj[currentKey] = [newValue] : currentObj[currentKey] = newValue : currentValue.pop ? currentValue.push(newValue) : currentObj[currentKey] = [currentValue, newValue];
            } else
              currentObj[currentKey] = newValue;
          }
          value = "", startingIndex = i, equalityIndex = i, shouldDecodeKey = false, shouldDecodeValue = false, keyHasPlus = false, valueHasPlus = false, keyIsDot = false, arrayRepeatBracketIndex = -1, keySeparatorIndex = i, currentObj = result, lastKey = void 0, currentKey = "";
        } else c === 93 ? (arrayRepeat && arrayRepeatSyntax === "bracket" && prevChar === 91 && (arrayRepeatBracketIndex = prevIndex), nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, void 0, void 0)), lastKey = currentKey, keyHasPlus = false, shouldDecodeKey = false), keySeparatorIndex = i, keyIsDot = false)) : c === 46 ? nesting && (nestingSyntax === "dot" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = false, shouldDecodeKey = false), keyIsDot = true, keySeparatorIndex = i) : c === 91 ? nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), isJsNestingSyntax && lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = false, shouldDecodeKey = false, keyIsDot = false), keySeparatorIndex = i) : c === 61 ? equalityIndex <= startingIndex ? equalityIndex = i : shouldDecodeValue = true : c === 43 ? equalityIndex > startingIndex ? valueHasPlus = true : keyHasPlus = true : c === 37 && (equalityIndex > startingIndex ? shouldDecodeValue = true : shouldDecodeKey = true);
        prevIndex = i, prevChar = c;
      }
      return result;
    }
  }
});
var require_stringify = __commonJS({
  "../node_modules/picoquery/lib/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = stringify2;
    var object_util_js_1 = require_object_util();
    function stringify2(input, options) {
      if (input === null || typeof input != "object")
        return "";
      let optionsObj = options ?? {};
      return (0, object_util_js_1.stringifyObject)(input, optionsObj);
    }
  }
});
var require_main = __commonJS({
  "../node_modules/picoquery/lib/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: true, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    })), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = exports.parse = void 0;
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_js_1.parse;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    __exportStar(require_shared(), exports);
  }
});

// node_modules/storybook/dist/_browser-chunks/chunk-QKODTO7K.js
function noop() {
}

// node_modules/storybook/dist/_browser-chunks/chunk-3IAH5M2U.js
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
function isEqualWith(a, b, areValuesEqual) {
  return isEqualWithImpl(a, b, void 0, void 0, void 0, void 0, areValuesEqual);
}
function isEqualWithImpl(a, b, property, aParent, bParent, stack, areValuesEqual) {
  let result = areValuesEqual(a, b, property, aParent, bParent, stack);
  if (result !== void 0)
    return result;
  if (typeof a == typeof b)
    switch (typeof a) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return a === b;
      case "number":
        return a === b || Object.is(a, b);
      case "function":
        return a === b;
      case "object":
        return areObjectsEqual(a, b, stack, areValuesEqual);
    }
  return areObjectsEqual(a, b, stack, areValuesEqual);
}
function areObjectsEqual(a, b, stack, areValuesEqual) {
  if (Object.is(a, b))
    return true;
  let aTag = getTag(a), bTag = getTag(b);
  if (aTag === argumentsTag && (aTag = objectTag), bTag === argumentsTag && (bTag = objectTag), aTag !== bTag)
    return false;
  switch (aTag) {
    case stringTag:
      return a.toString() === b.toString();
    case numberTag: {
      let x = a.valueOf(), y = b.valueOf();
      return eq(x, y);
    }
    case booleanTag:
    case dateTag:
    case symbolTag:
      return Object.is(a.valueOf(), b.valueOf());
    case regexpTag:
      return a.source === b.source && a.flags === b.flags;
    case functionTag:
      return a === b;
  }
  stack = stack ?? /* @__PURE__ */ new Map();
  let aStack = stack.get(a), bStack = stack.get(b);
  if (aStack != null && bStack != null)
    return aStack === b;
  stack.set(a, b), stack.set(b, a);
  try {
    switch (aTag) {
      case mapTag: {
        if (a.size !== b.size)
          return false;
        for (let [key, value] of a.entries())
          if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack, areValuesEqual))
            return false;
        return true;
      }
      case setTag: {
        if (a.size !== b.size)
          return false;
        let aValues = Array.from(a.values()), bValues = Array.from(b.values());
        for (let i = 0; i < aValues.length; i++) {
          let aValue = aValues[i], index = bValues.findIndex((bValue) => isEqualWithImpl(aValue, bValue, void 0, a, b, stack, areValuesEqual));
          if (index === -1)
            return false;
          bValues.splice(index, 1);
        }
        return true;
      }
      case arrayTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
      case bigUint64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case bigInt64ArrayTag:
      case float32ArrayTag:
      case float64ArrayTag: {
        if (typeof Buffer < "u" && Buffer.isBuffer(a) !== Buffer.isBuffer(b) || a.length !== b.length)
          return false;
        for (let i = 0; i < a.length; i++)
          if (!isEqualWithImpl(a[i], b[i], i, a, b, stack, areValuesEqual))
            return false;
        return true;
      }
      case arrayBufferTag:
        return a.byteLength !== b.byteLength ? false : areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);
      case dataViewTag:
        return a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset ? false : areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);
      case errorTag:
        return a.name === b.name && a.message === b.message;
      case objectTag: {
        if (!(areObjectsEqual(a.constructor, b.constructor, stack, areValuesEqual) || isPlainObject(a) && isPlainObject(b)))
          return false;
        let aKeys = [...Object.keys(a), ...getSymbols(a)], bKeys = [...Object.keys(b), ...getSymbols(b)];
        if (aKeys.length !== bKeys.length)
          return false;
        for (let i = 0; i < aKeys.length; i++) {
          let propKey = aKeys[i], aProp = a[propKey];
          if (!Object.hasOwn(b, propKey))
            return false;
          let bProp = b[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack, areValuesEqual))
            return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    stack.delete(a), stack.delete(b);
  }
}
function isEqual(a, b) {
  return isEqualWith(a, b, noop);
}

// node_modules/storybook/dist/_browser-chunks/chunk-YKE5S47A.js
var require_entities = __commonJS({
  "../node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = { Aacute: "Ã", aacute: "Ã¡", Abreve: "Ä‚", abreve: "Äƒ", ac: "âˆ¾", acd: "âˆ¿", acE: "âˆ¾Ì³", Acirc: "Ã‚", acirc: "Ã¢", acute: "Â´", Acy: "Ð", acy: "Ð°", AElig: "Ã†", aelig: "Ã¦", af: "â¡", Afr: "ð”„", afr: "ð”ž", Agrave: "Ã€", agrave: "Ã ", alefsym: "â„µ", aleph: "â„µ", Alpha: "Î‘", alpha: "Î±", Amacr: "Ä€", amacr: "Ä", amalg: "â¨¿", amp: "&", AMP: "&", andand: "â©•", And: "â©“", and: "âˆ§", andd: "â©œ", andslope: "â©˜", andv: "â©š", ang: "âˆ ", ange: "â¦¤", angle: "âˆ ", angmsdaa: "â¦¨", angmsdab: "â¦©", angmsdac: "â¦ª", angmsdad: "â¦«", angmsdae: "â¦¬", angmsdaf: "â¦­", angmsdag: "â¦®", angmsdah: "â¦¯", angmsd: "âˆ¡", angrt: "âˆŸ", angrtvb: "âŠ¾", angrtvbd: "â¦", angsph: "âˆ¢", angst: "Ã…", angzarr: "â¼", Aogon: "Ä„", aogon: "Ä…", Aopf: "ð”¸", aopf: "ð•’", apacir: "â©¯", ap: "â‰ˆ", apE: "â©°", ape: "â‰Š", apid: "â‰‹", apos: "'", ApplyFunction: "â¡", approx: "â‰ˆ", approxeq: "â‰Š", Aring: "Ã…", aring: "Ã¥", Ascr: "ð’œ", ascr: "ð’¶", Assign: "â‰”", ast: "*", asymp: "â‰ˆ", asympeq: "â‰", Atilde: "Ãƒ", atilde: "Ã£", Auml: "Ã„", auml: "Ã¤", awconint: "âˆ³", awint: "â¨‘", backcong: "â‰Œ", backepsilon: "Ï¶", backprime: "â€µ", backsim: "âˆ½", backsimeq: "â‹", Backslash: "âˆ–", Barv: "â«§", barvee: "âŠ½", barwed: "âŒ…", Barwed: "âŒ†", barwedge: "âŒ…", bbrk: "âŽµ", bbrktbrk: "âŽ¶", bcong: "â‰Œ", Bcy: "Ð‘", bcy: "Ð±", bdquo: "â€ž", becaus: "âˆµ", because: "âˆµ", Because: "âˆµ", bemptyv: "â¦°", bepsi: "Ï¶", bernou: "â„¬", Bernoullis: "â„¬", Beta: "Î’", beta: "Î²", beth: "â„¶", between: "â‰¬", Bfr: "ð”…", bfr: "ð”Ÿ", bigcap: "â‹‚", bigcirc: "â—¯", bigcup: "â‹ƒ", bigodot: "â¨€", bigoplus: "â¨", bigotimes: "â¨‚", bigsqcup: "â¨†", bigstar: "â˜…", bigtriangledown: "â–½", bigtriangleup: "â–³", biguplus: "â¨„", bigvee: "â‹", bigwedge: "â‹€", bkarow: "â¤", blacklozenge: "â§«", blacksquare: "â–ª", blacktriangle: "â–´", blacktriangledown: "â–¾", blacktriangleleft: "â—‚", blacktriangleright: "â–¸", blank: "â£", blk12: "â–’", blk14: "â–‘", blk34: "â–“", block: "â–ˆ", bne: "=âƒ¥", bnequiv: "â‰¡âƒ¥", bNot: "â«­", bnot: "âŒ", Bopf: "ð”¹", bopf: "ð•“", bot: "âŠ¥", bottom: "âŠ¥", bowtie: "â‹ˆ", boxbox: "â§‰", boxdl: "â”", boxdL: "â••", boxDl: "â•–", boxDL: "â•—", boxdr: "â”Œ", boxdR: "â•’", boxDr: "â•“", boxDR: "â•”", boxh: "â”€", boxH: "â•", boxhd: "â”¬", boxHd: "â•¤", boxhD: "â•¥", boxHD: "â•¦", boxhu: "â”´", boxHu: "â•§", boxhU: "â•¨", boxHU: "â•©", boxminus: "âŠŸ", boxplus: "âŠž", boxtimes: "âŠ ", boxul: "â”˜", boxuL: "â•›", boxUl: "â•œ", boxUL: "â•", boxur: "â””", boxuR: "â•˜", boxUr: "â•™", boxUR: "â•š", boxv: "â”‚", boxV: "â•‘", boxvh: "â”¼", boxvH: "â•ª", boxVh: "â•«", boxVH: "â•¬", boxvl: "â”¤", boxvL: "â•¡", boxVl: "â•¢", boxVL: "â•£", boxvr: "â”œ", boxvR: "â•ž", boxVr: "â•Ÿ", boxVR: "â• ", bprime: "â€µ", breve: "Ë˜", Breve: "Ë˜", brvbar: "Â¦", bscr: "ð’·", Bscr: "â„¬", bsemi: "â", bsim: "âˆ½", bsime: "â‹", bsolb: "â§…", bsol: "\\", bsolhsub: "âŸˆ", bull: "â€¢", bullet: "â€¢", bump: "â‰Ž", bumpE: "âª®", bumpe: "â‰", Bumpeq: "â‰Ž", bumpeq: "â‰", Cacute: "Ä†", cacute: "Ä‡", capand: "â©„", capbrcup: "â©‰", capcap: "â©‹", cap: "âˆ©", Cap: "â‹’", capcup: "â©‡", capdot: "â©€", CapitalDifferentialD: "â……", caps: "âˆ©ï¸€", caret: "â", caron: "Ë‡", Cayleys: "â„­", ccaps: "â©", Ccaron: "ÄŒ", ccaron: "Ä", Ccedil: "Ã‡", ccedil: "Ã§", Ccirc: "Äˆ", ccirc: "Ä‰", Cconint: "âˆ°", ccups: "â©Œ", ccupssm: "â©", Cdot: "ÄŠ", cdot: "Ä‹", cedil: "Â¸", Cedilla: "Â¸", cemptyv: "â¦²", cent: "Â¢", centerdot: "Â·", CenterDot: "Â·", cfr: "ð” ", Cfr: "â„­", CHcy: "Ð§", chcy: "Ñ‡", check: "âœ“", checkmark: "âœ“", Chi: "Î§", chi: "Ï‡", circ: "Ë†", circeq: "â‰—", circlearrowleft: "â†º", circlearrowright: "â†»", circledast: "âŠ›", circledcirc: "âŠš", circleddash: "âŠ", CircleDot: "âŠ™", circledR: "Â®", circledS: "â“ˆ", CircleMinus: "âŠ–", CirclePlus: "âŠ•", CircleTimes: "âŠ—", cir: "â—‹", cirE: "â§ƒ", cire: "â‰—", cirfnint: "â¨", cirmid: "â«¯", cirscir: "â§‚", ClockwiseContourIntegral: "âˆ²", CloseCurlyDoubleQuote: "â€", CloseCurlyQuote: "â€™", clubs: "â™£", clubsuit: "â™£", colon: ":", Colon: "âˆ·", Colone: "â©´", colone: "â‰”", coloneq: "â‰”", comma: ",", commat: "@", comp: "âˆ", compfn: "âˆ˜", complement: "âˆ", complexes: "â„‚", cong: "â‰…", congdot: "â©­", Congruent: "â‰¡", conint: "âˆ®", Conint: "âˆ¯", ContourIntegral: "âˆ®", copf: "ð•”", Copf: "â„‚", coprod: "âˆ", Coproduct: "âˆ", copy: "Â©", COPY: "Â©", copysr: "â„—", CounterClockwiseContourIntegral: "âˆ³", crarr: "â†µ", cross: "âœ—", Cross: "â¨¯", Cscr: "ð’ž", cscr: "ð’¸", csub: "â«", csube: "â«‘", csup: "â«", csupe: "â«’", ctdot: "â‹¯", cudarrl: "â¤¸", cudarrr: "â¤µ", cuepr: "â‹ž", cuesc: "â‹Ÿ", cularr: "â†¶", cularrp: "â¤½", cupbrcap: "â©ˆ", cupcap: "â©†", CupCap: "â‰", cup: "âˆª", Cup: "â‹“", cupcup: "â©Š", cupdot: "âŠ", cupor: "â©…", cups: "âˆªï¸€", curarr: "â†·", curarrm: "â¤¼", curlyeqprec: "â‹ž", curlyeqsucc: "â‹Ÿ", curlyvee: "â‹Ž", curlywedge: "â‹", curren: "Â¤", curvearrowleft: "â†¶", curvearrowright: "â†·", cuvee: "â‹Ž", cuwed: "â‹", cwconint: "âˆ²", cwint: "âˆ±", cylcty: "âŒ­", dagger: "â€ ", Dagger: "â€¡", daleth: "â„¸", darr: "â†“", Darr: "â†¡", dArr: "â‡“", dash: "â€", Dashv: "â«¤", dashv: "âŠ£", dbkarow: "â¤", dblac: "Ë", Dcaron: "ÄŽ", dcaron: "Ä", Dcy: "Ð”", dcy: "Ð´", ddagger: "â€¡", ddarr: "â‡Š", DD: "â……", dd: "â…†", DDotrahd: "â¤‘", ddotseq: "â©·", deg: "Â°", Del: "âˆ‡", Delta: "Î”", delta: "Î´", demptyv: "â¦±", dfisht: "â¥¿", Dfr: "ð”‡", dfr: "ð”¡", dHar: "â¥¥", dharl: "â‡ƒ", dharr: "â‡‚", DiacriticalAcute: "Â´", DiacriticalDot: "Ë™", DiacriticalDoubleAcute: "Ë", DiacriticalGrave: "`", DiacriticalTilde: "Ëœ", diam: "â‹„", diamond: "â‹„", Diamond: "â‹„", diamondsuit: "â™¦", diams: "â™¦", die: "Â¨", DifferentialD: "â…†", digamma: "Ï", disin: "â‹²", div: "Ã·", divide: "Ã·", divideontimes: "â‹‡", divonx: "â‹‡", DJcy: "Ð‚", djcy: "Ñ’", dlcorn: "âŒž", dlcrop: "âŒ", dollar: "$", Dopf: "ð”»", dopf: "ð••", Dot: "Â¨", dot: "Ë™", DotDot: "âƒœ", doteq: "â‰", doteqdot: "â‰‘", DotEqual: "â‰", dotminus: "âˆ¸", dotplus: "âˆ”", dotsquare: "âŠ¡", doublebarwedge: "âŒ†", DoubleContourIntegral: "âˆ¯", DoubleDot: "Â¨", DoubleDownArrow: "â‡“", DoubleLeftArrow: "â‡", DoubleLeftRightArrow: "â‡”", DoubleLeftTee: "â«¤", DoubleLongLeftArrow: "âŸ¸", DoubleLongLeftRightArrow: "âŸº", DoubleLongRightArrow: "âŸ¹", DoubleRightArrow: "â‡’", DoubleRightTee: "âŠ¨", DoubleUpArrow: "â‡‘", DoubleUpDownArrow: "â‡•", DoubleVerticalBar: "âˆ¥", DownArrowBar: "â¤“", downarrow: "â†“", DownArrow: "â†“", Downarrow: "â‡“", DownArrowUpArrow: "â‡µ", DownBreve: "Ì‘", downdownarrows: "â‡Š", downharpoonleft: "â‡ƒ", downharpoonright: "â‡‚", DownLeftRightVector: "â¥", DownLeftTeeVector: "â¥ž", DownLeftVectorBar: "â¥–", DownLeftVector: "â†½", DownRightTeeVector: "â¥Ÿ", DownRightVectorBar: "â¥—", DownRightVector: "â‡", DownTeeArrow: "â†§", DownTee: "âŠ¤", drbkarow: "â¤", drcorn: "âŒŸ", drcrop: "âŒŒ", Dscr: "ð’Ÿ", dscr: "ð’¹", DScy: "Ð…", dscy: "Ñ•", dsol: "â§¶", Dstrok: "Ä", dstrok: "Ä‘", dtdot: "â‹±", dtri: "â–¿", dtrif: "â–¾", duarr: "â‡µ", duhar: "â¥¯", dwangle: "â¦¦", DZcy: "Ð", dzcy: "ÑŸ", dzigrarr: "âŸ¿", Eacute: "Ã‰", eacute: "Ã©", easter: "â©®", Ecaron: "Äš", ecaron: "Ä›", Ecirc: "ÃŠ", ecirc: "Ãª", ecir: "â‰–", ecolon: "â‰•", Ecy: "Ð­", ecy: "Ñ", eDDot: "â©·", Edot: "Ä–", edot: "Ä—", eDot: "â‰‘", ee: "â…‡", efDot: "â‰’", Efr: "ð”ˆ", efr: "ð”¢", eg: "âªš", Egrave: "Ãˆ", egrave: "Ã¨", egs: "âª–", egsdot: "âª˜", el: "âª™", Element: "âˆˆ", elinters: "â§", ell: "â„“", els: "âª•", elsdot: "âª—", Emacr: "Ä’", emacr: "Ä“", empty: "âˆ…", emptyset: "âˆ…", EmptySmallSquare: "â—»", emptyv: "âˆ…", EmptyVerySmallSquare: "â–«", emsp13: "â€„", emsp14: "â€…", emsp: "â€ƒ", ENG: "ÅŠ", eng: "Å‹", ensp: "â€‚", Eogon: "Ä˜", eogon: "Ä™", Eopf: "ð”¼", eopf: "ð•–", epar: "â‹•", eparsl: "â§£", eplus: "â©±", epsi: "Îµ", Epsilon: "Î•", epsilon: "Îµ", epsiv: "Ïµ", eqcirc: "â‰–", eqcolon: "â‰•", eqsim: "â‰‚", eqslantgtr: "âª–", eqslantless: "âª•", Equal: "â©µ", equals: "=", EqualTilde: "â‰‚", equest: "â‰Ÿ", Equilibrium: "â‡Œ", equiv: "â‰¡", equivDD: "â©¸", eqvparsl: "â§¥", erarr: "â¥±", erDot: "â‰“", escr: "â„¯", Escr: "â„°", esdot: "â‰", Esim: "â©³", esim: "â‰‚", Eta: "Î—", eta: "Î·", ETH: "Ã", eth: "Ã°", Euml: "Ã‹", euml: "Ã«", euro: "â‚¬", excl: "!", exist: "âˆƒ", Exists: "âˆƒ", expectation: "â„°", exponentiale: "â…‡", ExponentialE: "â…‡", fallingdotseq: "â‰’", Fcy: "Ð¤", fcy: "Ñ„", female: "â™€", ffilig: "ï¬ƒ", fflig: "ï¬€", ffllig: "ï¬„", Ffr: "ð”‰", ffr: "ð”£", filig: "ï¬", FilledSmallSquare: "â—¼", FilledVerySmallSquare: "â–ª", fjlig: "fj", flat: "â™­", fllig: "ï¬‚", fltns: "â–±", fnof: "Æ’", Fopf: "ð”½", fopf: "ð•—", forall: "âˆ€", ForAll: "âˆ€", fork: "â‹”", forkv: "â«™", Fouriertrf: "â„±", fpartint: "â¨", frac12: "Â½", frac13: "â…“", frac14: "Â¼", frac15: "â…•", frac16: "â…™", frac18: "â…›", frac23: "â…”", frac25: "â…–", frac34: "Â¾", frac35: "â…—", frac38: "â…œ", frac45: "â…˜", frac56: "â…š", frac58: "â…", frac78: "â…ž", frasl: "â„", frown: "âŒ¢", fscr: "ð’»", Fscr: "â„±", gacute: "Çµ", Gamma: "Î“", gamma: "Î³", Gammad: "Ïœ", gammad: "Ï", gap: "âª†", Gbreve: "Äž", gbreve: "ÄŸ", Gcedil: "Ä¢", Gcirc: "Äœ", gcirc: "Ä", Gcy: "Ð“", gcy: "Ð³", Gdot: "Ä ", gdot: "Ä¡", ge: "â‰¥", gE: "â‰§", gEl: "âªŒ", gel: "â‹›", geq: "â‰¥", geqq: "â‰§", geqslant: "â©¾", gescc: "âª©", ges: "â©¾", gesdot: "âª€", gesdoto: "âª‚", gesdotol: "âª„", gesl: "â‹›ï¸€", gesles: "âª”", Gfr: "ð”Š", gfr: "ð”¤", gg: "â‰«", Gg: "â‹™", ggg: "â‹™", gimel: "â„·", GJcy: "Ðƒ", gjcy: "Ñ“", gla: "âª¥", gl: "â‰·", glE: "âª’", glj: "âª¤", gnap: "âªŠ", gnapprox: "âªŠ", gne: "âªˆ", gnE: "â‰©", gneq: "âªˆ", gneqq: "â‰©", gnsim: "â‹§", Gopf: "ð”¾", gopf: "ð•˜", grave: "`", GreaterEqual: "â‰¥", GreaterEqualLess: "â‹›", GreaterFullEqual: "â‰§", GreaterGreater: "âª¢", GreaterLess: "â‰·", GreaterSlantEqual: "â©¾", GreaterTilde: "â‰³", Gscr: "ð’¢", gscr: "â„Š", gsim: "â‰³", gsime: "âªŽ", gsiml: "âª", gtcc: "âª§", gtcir: "â©º", gt: ">", GT: ">", Gt: "â‰«", gtdot: "â‹—", gtlPar: "â¦•", gtquest: "â©¼", gtrapprox: "âª†", gtrarr: "â¥¸", gtrdot: "â‹—", gtreqless: "â‹›", gtreqqless: "âªŒ", gtrless: "â‰·", gtrsim: "â‰³", gvertneqq: "â‰©ï¸€", gvnE: "â‰©ï¸€", Hacek: "Ë‡", hairsp: "â€Š", half: "Â½", hamilt: "â„‹", HARDcy: "Ðª", hardcy: "ÑŠ", harrcir: "â¥ˆ", harr: "â†”", hArr: "â‡”", harrw: "â†­", Hat: "^", hbar: "â„", Hcirc: "Ä¤", hcirc: "Ä¥", hearts: "â™¥", heartsuit: "â™¥", hellip: "â€¦", hercon: "âŠ¹", hfr: "ð”¥", Hfr: "â„Œ", HilbertSpace: "â„‹", hksearow: "â¤¥", hkswarow: "â¤¦", hoarr: "â‡¿", homtht: "âˆ»", hookleftarrow: "â†©", hookrightarrow: "â†ª", hopf: "ð•™", Hopf: "â„", horbar: "â€•", HorizontalLine: "â”€", hscr: "ð’½", Hscr: "â„‹", hslash: "â„", Hstrok: "Ä¦", hstrok: "Ä§", HumpDownHump: "â‰Ž", HumpEqual: "â‰", hybull: "âƒ", hyphen: "â€", Iacute: "Ã", iacute: "Ã­", ic: "â£", Icirc: "ÃŽ", icirc: "Ã®", Icy: "Ð˜", icy: "Ð¸", Idot: "Ä°", IEcy: "Ð•", iecy: "Ðµ", iexcl: "Â¡", iff: "â‡”", ifr: "ð”¦", Ifr: "â„‘", Igrave: "ÃŒ", igrave: "Ã¬", ii: "â…ˆ", iiiint: "â¨Œ", iiint: "âˆ­", iinfin: "â§œ", iiota: "â„©", IJlig: "Ä²", ijlig: "Ä³", Imacr: "Äª", imacr: "Ä«", image: "â„‘", ImaginaryI: "â…ˆ", imagline: "â„", imagpart: "â„‘", imath: "Ä±", Im: "â„‘", imof: "âŠ·", imped: "Æµ", Implies: "â‡’", incare: "â„…", in: "âˆˆ", infin: "âˆž", infintie: "â§", inodot: "Ä±", intcal: "âŠº", int: "âˆ«", Int: "âˆ¬", integers: "â„¤", Integral: "âˆ«", intercal: "âŠº", Intersection: "â‹‚", intlarhk: "â¨—", intprod: "â¨¼", InvisibleComma: "â£", InvisibleTimes: "â¢", IOcy: "Ð", iocy: "Ñ‘", Iogon: "Ä®", iogon: "Ä¯", Iopf: "ð•€", iopf: "ð•š", Iota: "Î™", iota: "Î¹", iprod: "â¨¼", iquest: "Â¿", iscr: "ð’¾", Iscr: "â„", isin: "âˆˆ", isindot: "â‹µ", isinE: "â‹¹", isins: "â‹´", isinsv: "â‹³", isinv: "âˆˆ", it: "â¢", Itilde: "Ä¨", itilde: "Ä©", Iukcy: "Ð†", iukcy: "Ñ–", Iuml: "Ã", iuml: "Ã¯", Jcirc: "Ä´", jcirc: "Äµ", Jcy: "Ð™", jcy: "Ð¹", Jfr: "ð”", jfr: "ð”§", jmath: "È·", Jopf: "ð•", jopf: "ð•›", Jscr: "ð’¥", jscr: "ð’¿", Jsercy: "Ðˆ", jsercy: "Ñ˜", Jukcy: "Ð„", jukcy: "Ñ”", Kappa: "Îš", kappa: "Îº", kappav: "Ï°", Kcedil: "Ä¶", kcedil: "Ä·", Kcy: "Ðš", kcy: "Ðº", Kfr: "ð”Ž", kfr: "ð”¨", kgreen: "Ä¸", KHcy: "Ð¥", khcy: "Ñ…", KJcy: "ÐŒ", kjcy: "Ñœ", Kopf: "ð•‚", kopf: "ð•œ", Kscr: "ð’¦", kscr: "ð“€", lAarr: "â‡š", Lacute: "Ä¹", lacute: "Äº", laemptyv: "â¦´", lagran: "â„’", Lambda: "Î›", lambda: "Î»", lang: "âŸ¨", Lang: "âŸª", langd: "â¦‘", langle: "âŸ¨", lap: "âª…", Laplacetrf: "â„’", laquo: "Â«", larrb: "â‡¤", larrbfs: "â¤Ÿ", larr: "â†", Larr: "â†ž", lArr: "â‡", larrfs: "â¤", larrhk: "â†©", larrlp: "â†«", larrpl: "â¤¹", larrsim: "â¥³", larrtl: "â†¢", latail: "â¤™", lAtail: "â¤›", lat: "âª«", late: "âª­", lates: "âª­ï¸€", lbarr: "â¤Œ", lBarr: "â¤Ž", lbbrk: "â²", lbrace: "{", lbrack: "[", lbrke: "â¦‹", lbrksld: "â¦", lbrkslu: "â¦", Lcaron: "Ä½", lcaron: "Ä¾", Lcedil: "Ä»", lcedil: "Ä¼", lceil: "âŒˆ", lcub: "{", Lcy: "Ð›", lcy: "Ð»", ldca: "â¤¶", ldquo: "â€œ", ldquor: "â€ž", ldrdhar: "â¥§", ldrushar: "â¥‹", ldsh: "â†²", le: "â‰¤", lE: "â‰¦", LeftAngleBracket: "âŸ¨", LeftArrowBar: "â‡¤", leftarrow: "â†", LeftArrow: "â†", Leftarrow: "â‡", LeftArrowRightArrow: "â‡†", leftarrowtail: "â†¢", LeftCeiling: "âŒˆ", LeftDoubleBracket: "âŸ¦", LeftDownTeeVector: "â¥¡", LeftDownVectorBar: "â¥™", LeftDownVector: "â‡ƒ", LeftFloor: "âŒŠ", leftharpoondown: "â†½", leftharpoonup: "â†¼", leftleftarrows: "â‡‡", leftrightarrow: "â†”", LeftRightArrow: "â†”", Leftrightarrow: "â‡”", leftrightarrows: "â‡†", leftrightharpoons: "â‡‹", leftrightsquigarrow: "â†­", LeftRightVector: "â¥Ž", LeftTeeArrow: "â†¤", LeftTee: "âŠ£", LeftTeeVector: "â¥š", leftthreetimes: "â‹‹", LeftTriangleBar: "â§", LeftTriangle: "âŠ²", LeftTriangleEqual: "âŠ´", LeftUpDownVector: "â¥‘", LeftUpTeeVector: "â¥ ", LeftUpVectorBar: "â¥˜", LeftUpVector: "â†¿", LeftVectorBar: "â¥’", LeftVector: "â†¼", lEg: "âª‹", leg: "â‹š", leq: "â‰¤", leqq: "â‰¦", leqslant: "â©½", lescc: "âª¨", les: "â©½", lesdot: "â©¿", lesdoto: "âª", lesdotor: "âªƒ", lesg: "â‹šï¸€", lesges: "âª“", lessapprox: "âª…", lessdot: "â‹–", lesseqgtr: "â‹š", lesseqqgtr: "âª‹", LessEqualGreater: "â‹š", LessFullEqual: "â‰¦", LessGreater: "â‰¶", lessgtr: "â‰¶", LessLess: "âª¡", lesssim: "â‰²", LessSlantEqual: "â©½", LessTilde: "â‰²", lfisht: "â¥¼", lfloor: "âŒŠ", Lfr: "ð”", lfr: "ð”©", lg: "â‰¶", lgE: "âª‘", lHar: "â¥¢", lhard: "â†½", lharu: "â†¼", lharul: "â¥ª", lhblk: "â–„", LJcy: "Ð‰", ljcy: "Ñ™", llarr: "â‡‡", ll: "â‰ª", Ll: "â‹˜", llcorner: "âŒž", Lleftarrow: "â‡š", llhard: "â¥«", lltri: "â—º", Lmidot: "Ä¿", lmidot: "Å€", lmoustache: "âŽ°", lmoust: "âŽ°", lnap: "âª‰", lnapprox: "âª‰", lne: "âª‡", lnE: "â‰¨", lneq: "âª‡", lneqq: "â‰¨", lnsim: "â‹¦", loang: "âŸ¬", loarr: "â‡½", lobrk: "âŸ¦", longleftarrow: "âŸµ", LongLeftArrow: "âŸµ", Longleftarrow: "âŸ¸", longleftrightarrow: "âŸ·", LongLeftRightArrow: "âŸ·", Longleftrightarrow: "âŸº", longmapsto: "âŸ¼", longrightarrow: "âŸ¶", LongRightArrow: "âŸ¶", Longrightarrow: "âŸ¹", looparrowleft: "â†«", looparrowright: "â†¬", lopar: "â¦…", Lopf: "ð•ƒ", lopf: "ð•", loplus: "â¨­", lotimes: "â¨´", lowast: "âˆ—", lowbar: "_", LowerLeftArrow: "â†™", LowerRightArrow: "â†˜", loz: "â—Š", lozenge: "â—Š", lozf: "â§«", lpar: "(", lparlt: "â¦“", lrarr: "â‡†", lrcorner: "âŒŸ", lrhar: "â‡‹", lrhard: "â¥­", lrm: "â€Ž", lrtri: "âŠ¿", lsaquo: "â€¹", lscr: "ð“", Lscr: "â„’", lsh: "â†°", Lsh: "â†°", lsim: "â‰²", lsime: "âª", lsimg: "âª", lsqb: "[", lsquo: "â€˜", lsquor: "â€š", Lstrok: "Å", lstrok: "Å‚", ltcc: "âª¦", ltcir: "â©¹", lt: "<", LT: "<", Lt: "â‰ª", ltdot: "â‹–", lthree: "â‹‹", ltimes: "â‹‰", ltlarr: "â¥¶", ltquest: "â©»", ltri: "â—ƒ", ltrie: "âŠ´", ltrif: "â—‚", ltrPar: "â¦–", lurdshar: "â¥Š", luruhar: "â¥¦", lvertneqq: "â‰¨ï¸€", lvnE: "â‰¨ï¸€", macr: "Â¯", male: "â™‚", malt: "âœ ", maltese: "âœ ", Map: "â¤…", map: "â†¦", mapsto: "â†¦", mapstodown: "â†§", mapstoleft: "â†¤", mapstoup: "â†¥", marker: "â–®", mcomma: "â¨©", Mcy: "Ðœ", mcy: "Ð¼", mdash: "â€”", mDDot: "âˆº", measuredangle: "âˆ¡", MediumSpace: "âŸ", Mellintrf: "â„³", Mfr: "ð”", mfr: "ð”ª", mho: "â„§", micro: "Âµ", midast: "*", midcir: "â«°", mid: "âˆ£", middot: "Â·", minusb: "âŠŸ", minus: "âˆ’", minusd: "âˆ¸", minusdu: "â¨ª", MinusPlus: "âˆ“", mlcp: "â«›", mldr: "â€¦", mnplus: "âˆ“", models: "âŠ§", Mopf: "ð•„", mopf: "ð•ž", mp: "âˆ“", mscr: "ð“‚", Mscr: "â„³", mstpos: "âˆ¾", Mu: "Îœ", mu: "Î¼", multimap: "âŠ¸", mumap: "âŠ¸", nabla: "âˆ‡", Nacute: "Åƒ", nacute: "Å„", nang: "âˆ âƒ’", nap: "â‰‰", napE: "â©°Ì¸", napid: "â‰‹Ì¸", napos: "Å‰", napprox: "â‰‰", natural: "â™®", naturals: "â„•", natur: "â™®", nbsp: "Â ", nbump: "â‰ŽÌ¸", nbumpe: "â‰Ì¸", ncap: "â©ƒ", Ncaron: "Å‡", ncaron: "Åˆ", Ncedil: "Å…", ncedil: "Å†", ncong: "â‰‡", ncongdot: "â©­Ì¸", ncup: "â©‚", Ncy: "Ð", ncy: "Ð½", ndash: "â€“", nearhk: "â¤¤", nearr: "â†—", neArr: "â‡—", nearrow: "â†—", ne: "â‰ ", nedot: "â‰Ì¸", NegativeMediumSpace: "â€‹", NegativeThickSpace: "â€‹", NegativeThinSpace: "â€‹", NegativeVeryThinSpace: "â€‹", nequiv: "â‰¢", nesear: "â¤¨", nesim: "â‰‚Ì¸", NestedGreaterGreater: "â‰«", NestedLessLess: "â‰ª", NewLine: `
`, nexist: "âˆ„", nexists: "âˆ„", Nfr: "ð”‘", nfr: "ð”«", ngE: "â‰§Ì¸", nge: "â‰±", ngeq: "â‰±", ngeqq: "â‰§Ì¸", ngeqslant: "â©¾Ì¸", nges: "â©¾Ì¸", nGg: "â‹™Ì¸", ngsim: "â‰µ", nGt: "â‰«âƒ’", ngt: "â‰¯", ngtr: "â‰¯", nGtv: "â‰«Ì¸", nharr: "â†®", nhArr: "â‡Ž", nhpar: "â«²", ni: "âˆ‹", nis: "â‹¼", nisd: "â‹º", niv: "âˆ‹", NJcy: "ÐŠ", njcy: "Ñš", nlarr: "â†š", nlArr: "â‡", nldr: "â€¥", nlE: "â‰¦Ì¸", nle: "â‰°", nleftarrow: "â†š", nLeftarrow: "â‡", nleftrightarrow: "â†®", nLeftrightarrow: "â‡Ž", nleq: "â‰°", nleqq: "â‰¦Ì¸", nleqslant: "â©½Ì¸", nles: "â©½Ì¸", nless: "â‰®", nLl: "â‹˜Ì¸", nlsim: "â‰´", nLt: "â‰ªâƒ’", nlt: "â‰®", nltri: "â‹ª", nltrie: "â‹¬", nLtv: "â‰ªÌ¸", nmid: "âˆ¤", NoBreak: "â ", NonBreakingSpace: "Â ", nopf: "ð•Ÿ", Nopf: "â„•", Not: "â«¬", not: "Â¬", NotCongruent: "â‰¢", NotCupCap: "â‰­", NotDoubleVerticalBar: "âˆ¦", NotElement: "âˆ‰", NotEqual: "â‰ ", NotEqualTilde: "â‰‚Ì¸", NotExists: "âˆ„", NotGreater: "â‰¯", NotGreaterEqual: "â‰±", NotGreaterFullEqual: "â‰§Ì¸", NotGreaterGreater: "â‰«Ì¸", NotGreaterLess: "â‰¹", NotGreaterSlantEqual: "â©¾Ì¸", NotGreaterTilde: "â‰µ", NotHumpDownHump: "â‰ŽÌ¸", NotHumpEqual: "â‰Ì¸", notin: "âˆ‰", notindot: "â‹µÌ¸", notinE: "â‹¹Ì¸", notinva: "âˆ‰", notinvb: "â‹·", notinvc: "â‹¶", NotLeftTriangleBar: "â§Ì¸", NotLeftTriangle: "â‹ª", NotLeftTriangleEqual: "â‹¬", NotLess: "â‰®", NotLessEqual: "â‰°", NotLessGreater: "â‰¸", NotLessLess: "â‰ªÌ¸", NotLessSlantEqual: "â©½Ì¸", NotLessTilde: "â‰´", NotNestedGreaterGreater: "âª¢Ì¸", NotNestedLessLess: "âª¡Ì¸", notni: "âˆŒ", notniva: "âˆŒ", notnivb: "â‹¾", notnivc: "â‹½", NotPrecedes: "âŠ€", NotPrecedesEqual: "âª¯Ì¸", NotPrecedesSlantEqual: "â‹ ", NotReverseElement: "âˆŒ", NotRightTriangleBar: "â§Ì¸", NotRightTriangle: "â‹«", NotRightTriangleEqual: "â‹­", NotSquareSubset: "âŠÌ¸", NotSquareSubsetEqual: "â‹¢", NotSquareSuperset: "âŠÌ¸", NotSquareSupersetEqual: "â‹£", NotSubset: "âŠ‚âƒ’", NotSubsetEqual: "âŠˆ", NotSucceeds: "âŠ", NotSucceedsEqual: "âª°Ì¸", NotSucceedsSlantEqual: "â‹¡", NotSucceedsTilde: "â‰¿Ì¸", NotSuperset: "âŠƒâƒ’", NotSupersetEqual: "âŠ‰", NotTilde: "â‰", NotTildeEqual: "â‰„", NotTildeFullEqual: "â‰‡", NotTildeTilde: "â‰‰", NotVerticalBar: "âˆ¤", nparallel: "âˆ¦", npar: "âˆ¦", nparsl: "â«½âƒ¥", npart: "âˆ‚Ì¸", npolint: "â¨”", npr: "âŠ€", nprcue: "â‹ ", nprec: "âŠ€", npreceq: "âª¯Ì¸", npre: "âª¯Ì¸", nrarrc: "â¤³Ì¸", nrarr: "â†›", nrArr: "â‡", nrarrw: "â†Ì¸", nrightarrow: "â†›", nRightarrow: "â‡", nrtri: "â‹«", nrtrie: "â‹­", nsc: "âŠ", nsccue: "â‹¡", nsce: "âª°Ì¸", Nscr: "ð’©", nscr: "ð“ƒ", nshortmid: "âˆ¤", nshortparallel: "âˆ¦", nsim: "â‰", nsime: "â‰„", nsimeq: "â‰„", nsmid: "âˆ¤", nspar: "âˆ¦", nsqsube: "â‹¢", nsqsupe: "â‹£", nsub: "âŠ„", nsubE: "â«…Ì¸", nsube: "âŠˆ", nsubset: "âŠ‚âƒ’", nsubseteq: "âŠˆ", nsubseteqq: "â«…Ì¸", nsucc: "âŠ", nsucceq: "âª°Ì¸", nsup: "âŠ…", nsupE: "â«†Ì¸", nsupe: "âŠ‰", nsupset: "âŠƒâƒ’", nsupseteq: "âŠ‰", nsupseteqq: "â«†Ì¸", ntgl: "â‰¹", Ntilde: "Ã‘", ntilde: "Ã±", ntlg: "â‰¸", ntriangleleft: "â‹ª", ntrianglelefteq: "â‹¬", ntriangleright: "â‹«", ntrianglerighteq: "â‹­", Nu: "Î", nu: "Î½", num: "#", numero: "â„–", numsp: "â€‡", nvap: "â‰âƒ’", nvdash: "âŠ¬", nvDash: "âŠ­", nVdash: "âŠ®", nVDash: "âŠ¯", nvge: "â‰¥âƒ’", nvgt: ">âƒ’", nvHarr: "â¤„", nvinfin: "â§ž", nvlArr: "â¤‚", nvle: "â‰¤âƒ’", nvlt: "<âƒ’", nvltrie: "âŠ´âƒ’", nvrArr: "â¤ƒ", nvrtrie: "âŠµâƒ’", nvsim: "âˆ¼âƒ’", nwarhk: "â¤£", nwarr: "â†–", nwArr: "â‡–", nwarrow: "â†–", nwnear: "â¤§", Oacute: "Ã“", oacute: "Ã³", oast: "âŠ›", Ocirc: "Ã”", ocirc: "Ã´", ocir: "âŠš", Ocy: "Ðž", ocy: "Ð¾", odash: "âŠ", Odblac: "Å", odblac: "Å‘", odiv: "â¨¸", odot: "âŠ™", odsold: "â¦¼", OElig: "Å’", oelig: "Å“", ofcir: "â¦¿", Ofr: "ð”’", ofr: "ð”¬", ogon: "Ë›", Ograve: "Ã’", ograve: "Ã²", ogt: "â§", ohbar: "â¦µ", ohm: "Î©", oint: "âˆ®", olarr: "â†º", olcir: "â¦¾", olcross: "â¦»", oline: "â€¾", olt: "â§€", Omacr: "ÅŒ", omacr: "Å", Omega: "Î©", omega: "Ï‰", Omicron: "ÎŸ", omicron: "Î¿", omid: "â¦¶", ominus: "âŠ–", Oopf: "ð•†", oopf: "ð• ", opar: "â¦·", OpenCurlyDoubleQuote: "â€œ", OpenCurlyQuote: "â€˜", operp: "â¦¹", oplus: "âŠ•", orarr: "â†»", Or: "â©”", or: "âˆ¨", ord: "â©", order: "â„´", orderof: "â„´", ordf: "Âª", ordm: "Âº", origof: "âŠ¶", oror: "â©–", orslope: "â©—", orv: "â©›", oS: "â“ˆ", Oscr: "ð’ª", oscr: "â„´", Oslash: "Ã˜", oslash: "Ã¸", osol: "âŠ˜", Otilde: "Ã•", otilde: "Ãµ", otimesas: "â¨¶", Otimes: "â¨·", otimes: "âŠ—", Ouml: "Ã–", ouml: "Ã¶", ovbar: "âŒ½", OverBar: "â€¾", OverBrace: "âž", OverBracket: "âŽ´", OverParenthesis: "âœ", para: "Â¶", parallel: "âˆ¥", par: "âˆ¥", parsim: "â«³", parsl: "â«½", part: "âˆ‚", PartialD: "âˆ‚", Pcy: "ÐŸ", pcy: "Ð¿", percnt: "%", period: ".", permil: "â€°", perp: "âŠ¥", pertenk: "â€±", Pfr: "ð”“", pfr: "ð”­", Phi: "Î¦", phi: "Ï†", phiv: "Ï•", phmmat: "â„³", phone: "â˜Ž", Pi: "Î ", pi: "Ï€", pitchfork: "â‹”", piv: "Ï–", planck: "â„", planckh: "â„Ž", plankv: "â„", plusacir: "â¨£", plusb: "âŠž", pluscir: "â¨¢", plus: "+", plusdo: "âˆ”", plusdu: "â¨¥", pluse: "â©²", PlusMinus: "Â±", plusmn: "Â±", plussim: "â¨¦", plustwo: "â¨§", pm: "Â±", Poincareplane: "â„Œ", pointint: "â¨•", popf: "ð•¡", Popf: "â„™", pound: "Â£", prap: "âª·", Pr: "âª»", pr: "â‰º", prcue: "â‰¼", precapprox: "âª·", prec: "â‰º", preccurlyeq: "â‰¼", Precedes: "â‰º", PrecedesEqual: "âª¯", PrecedesSlantEqual: "â‰¼", PrecedesTilde: "â‰¾", preceq: "âª¯", precnapprox: "âª¹", precneqq: "âªµ", precnsim: "â‹¨", pre: "âª¯", prE: "âª³", precsim: "â‰¾", prime: "â€²", Prime: "â€³", primes: "â„™", prnap: "âª¹", prnE: "âªµ", prnsim: "â‹¨", prod: "âˆ", Product: "âˆ", profalar: "âŒ®", profline: "âŒ’", profsurf: "âŒ“", prop: "âˆ", Proportional: "âˆ", Proportion: "âˆ·", propto: "âˆ", prsim: "â‰¾", prurel: "âŠ°", Pscr: "ð’«", pscr: "ð“…", Psi: "Î¨", psi: "Ïˆ", puncsp: "â€ˆ", Qfr: "ð””", qfr: "ð”®", qint: "â¨Œ", qopf: "ð•¢", Qopf: "â„š", qprime: "â—", Qscr: "ð’¬", qscr: "ð“†", quaternions: "â„", quatint: "â¨–", quest: "?", questeq: "â‰Ÿ", quot: '"', QUOT: '"', rAarr: "â‡›", race: "âˆ½Ì±", Racute: "Å”", racute: "Å•", radic: "âˆš", raemptyv: "â¦³", rang: "âŸ©", Rang: "âŸ«", rangd: "â¦’", range: "â¦¥", rangle: "âŸ©", raquo: "Â»", rarrap: "â¥µ", rarrb: "â‡¥", rarrbfs: "â¤ ", rarrc: "â¤³", rarr: "â†’", Rarr: "â† ", rArr: "â‡’", rarrfs: "â¤ž", rarrhk: "â†ª", rarrlp: "â†¬", rarrpl: "â¥…", rarrsim: "â¥´", Rarrtl: "â¤–", rarrtl: "â†£", rarrw: "â†", ratail: "â¤š", rAtail: "â¤œ", ratio: "âˆ¶", rationals: "â„š", rbarr: "â¤", rBarr: "â¤", RBarr: "â¤", rbbrk: "â³", rbrace: "}", rbrack: "]", rbrke: "â¦Œ", rbrksld: "â¦Ž", rbrkslu: "â¦", Rcaron: "Å˜", rcaron: "Å™", Rcedil: "Å–", rcedil: "Å—", rceil: "âŒ‰", rcub: "}", Rcy: "Ð ", rcy: "Ñ€", rdca: "â¤·", rdldhar: "â¥©", rdquo: "â€", rdquor: "â€", rdsh: "â†³", real: "â„œ", realine: "â„›", realpart: "â„œ", reals: "â„", Re: "â„œ", rect: "â–­", reg: "Â®", REG: "Â®", ReverseElement: "âˆ‹", ReverseEquilibrium: "â‡‹", ReverseUpEquilibrium: "â¥¯", rfisht: "â¥½", rfloor: "âŒ‹", rfr: "ð”¯", Rfr: "â„œ", rHar: "â¥¤", rhard: "â‡", rharu: "â‡€", rharul: "â¥¬", Rho: "Î¡", rho: "Ï", rhov: "Ï±", RightAngleBracket: "âŸ©", RightArrowBar: "â‡¥", rightarrow: "â†’", RightArrow: "â†’", Rightarrow: "â‡’", RightArrowLeftArrow: "â‡„", rightarrowtail: "â†£", RightCeiling: "âŒ‰", RightDoubleBracket: "âŸ§", RightDownTeeVector: "â¥", RightDownVectorBar: "â¥•", RightDownVector: "â‡‚", RightFloor: "âŒ‹", rightharpoondown: "â‡", rightharpoonup: "â‡€", rightleftarrows: "â‡„", rightleftharpoons: "â‡Œ", rightrightarrows: "â‡‰", rightsquigarrow: "â†", RightTeeArrow: "â†¦", RightTee: "âŠ¢", RightTeeVector: "â¥›", rightthreetimes: "â‹Œ", RightTriangleBar: "â§", RightTriangle: "âŠ³", RightTriangleEqual: "âŠµ", RightUpDownVector: "â¥", RightUpTeeVector: "â¥œ", RightUpVectorBar: "â¥”", RightUpVector: "â†¾", RightVectorBar: "â¥“", RightVector: "â‡€", ring: "Ëš", risingdotseq: "â‰“", rlarr: "â‡„", rlhar: "â‡Œ", rlm: "â€", rmoustache: "âŽ±", rmoust: "âŽ±", rnmid: "â«®", roang: "âŸ­", roarr: "â‡¾", robrk: "âŸ§", ropar: "â¦†", ropf: "ð•£", Ropf: "â„", roplus: "â¨®", rotimes: "â¨µ", RoundImplies: "â¥°", rpar: ")", rpargt: "â¦”", rppolint: "â¨’", rrarr: "â‡‰", Rrightarrow: "â‡›", rsaquo: "â€º", rscr: "ð“‡", Rscr: "â„›", rsh: "â†±", Rsh: "â†±", rsqb: "]", rsquo: "â€™", rsquor: "â€™", rthree: "â‹Œ", rtimes: "â‹Š", rtri: "â–¹", rtrie: "âŠµ", rtrif: "â–¸", rtriltri: "â§Ž", RuleDelayed: "â§´", ruluhar: "â¥¨", rx: "â„ž", Sacute: "Åš", sacute: "Å›", sbquo: "â€š", scap: "âª¸", Scaron: "Å ", scaron: "Å¡", Sc: "âª¼", sc: "â‰»", sccue: "â‰½", sce: "âª°", scE: "âª´", Scedil: "Åž", scedil: "ÅŸ", Scirc: "Åœ", scirc: "Å", scnap: "âªº", scnE: "âª¶", scnsim: "â‹©", scpolint: "â¨“", scsim: "â‰¿", Scy: "Ð¡", scy: "Ñ", sdotb: "âŠ¡", sdot: "â‹…", sdote: "â©¦", searhk: "â¤¥", searr: "â†˜", seArr: "â‡˜", searrow: "â†˜", sect: "Â§", semi: ";", seswar: "â¤©", setminus: "âˆ–", setmn: "âˆ–", sext: "âœ¶", Sfr: "ð”–", sfr: "ð”°", sfrown: "âŒ¢", sharp: "â™¯", SHCHcy: "Ð©", shchcy: "Ñ‰", SHcy: "Ð¨", shcy: "Ñˆ", ShortDownArrow: "â†“", ShortLeftArrow: "â†", shortmid: "âˆ£", shortparallel: "âˆ¥", ShortRightArrow: "â†’", ShortUpArrow: "â†‘", shy: "Â­", Sigma: "Î£", sigma: "Ïƒ", sigmaf: "Ï‚", sigmav: "Ï‚", sim: "âˆ¼", simdot: "â©ª", sime: "â‰ƒ", simeq: "â‰ƒ", simg: "âªž", simgE: "âª ", siml: "âª", simlE: "âªŸ", simne: "â‰†", simplus: "â¨¤", simrarr: "â¥²", slarr: "â†", SmallCircle: "âˆ˜", smallsetminus: "âˆ–", smashp: "â¨³", smeparsl: "â§¤", smid: "âˆ£", smile: "âŒ£", smt: "âªª", smte: "âª¬", smtes: "âª¬ï¸€", SOFTcy: "Ð¬", softcy: "ÑŒ", solbar: "âŒ¿", solb: "â§„", sol: "/", Sopf: "ð•Š", sopf: "ð•¤", spades: "â™ ", spadesuit: "â™ ", spar: "âˆ¥", sqcap: "âŠ“", sqcaps: "âŠ“ï¸€", sqcup: "âŠ”", sqcups: "âŠ”ï¸€", Sqrt: "âˆš", sqsub: "âŠ", sqsube: "âŠ‘", sqsubset: "âŠ", sqsubseteq: "âŠ‘", sqsup: "âŠ", sqsupe: "âŠ’", sqsupset: "âŠ", sqsupseteq: "âŠ’", square: "â–¡", Square: "â–¡", SquareIntersection: "âŠ“", SquareSubset: "âŠ", SquareSubsetEqual: "âŠ‘", SquareSuperset: "âŠ", SquareSupersetEqual: "âŠ’", SquareUnion: "âŠ”", squarf: "â–ª", squ: "â–¡", squf: "â–ª", srarr: "â†’", Sscr: "ð’®", sscr: "ð“ˆ", ssetmn: "âˆ–", ssmile: "âŒ£", sstarf: "â‹†", Star: "â‹†", star: "â˜†", starf: "â˜…", straightepsilon: "Ïµ", straightphi: "Ï•", strns: "Â¯", sub: "âŠ‚", Sub: "â‹", subdot: "âª½", subE: "â«…", sube: "âŠ†", subedot: "â«ƒ", submult: "â«", subnE: "â«‹", subne: "âŠŠ", subplus: "âª¿", subrarr: "â¥¹", subset: "âŠ‚", Subset: "â‹", subseteq: "âŠ†", subseteqq: "â«…", SubsetEqual: "âŠ†", subsetneq: "âŠŠ", subsetneqq: "â«‹", subsim: "â«‡", subsub: "â«•", subsup: "â«“", succapprox: "âª¸", succ: "â‰»", succcurlyeq: "â‰½", Succeeds: "â‰»", SucceedsEqual: "âª°", SucceedsSlantEqual: "â‰½", SucceedsTilde: "â‰¿", succeq: "âª°", succnapprox: "âªº", succneqq: "âª¶", succnsim: "â‹©", succsim: "â‰¿", SuchThat: "âˆ‹", sum: "âˆ‘", Sum: "âˆ‘", sung: "â™ª", sup1: "Â¹", sup2: "Â²", sup3: "Â³", sup: "âŠƒ", Sup: "â‹‘", supdot: "âª¾", supdsub: "â«˜", supE: "â«†", supe: "âŠ‡", supedot: "â«„", Superset: "âŠƒ", SupersetEqual: "âŠ‡", suphsol: "âŸ‰", suphsub: "â«—", suplarr: "â¥»", supmult: "â«‚", supnE: "â«Œ", supne: "âŠ‹", supplus: "â«€", supset: "âŠƒ", Supset: "â‹‘", supseteq: "âŠ‡", supseteqq: "â«†", supsetneq: "âŠ‹", supsetneqq: "â«Œ", supsim: "â«ˆ", supsub: "â«”", supsup: "â«–", swarhk: "â¤¦", swarr: "â†™", swArr: "â‡™", swarrow: "â†™", swnwar: "â¤ª", szlig: "ÃŸ", Tab: "	", target: "âŒ–", Tau: "Î¤", tau: "Ï„", tbrk: "âŽ´", Tcaron: "Å¤", tcaron: "Å¥", Tcedil: "Å¢", tcedil: "Å£", Tcy: "Ð¢", tcy: "Ñ‚", tdot: "âƒ›", telrec: "âŒ•", Tfr: "ð”—", tfr: "ð”±", there4: "âˆ´", therefore: "âˆ´", Therefore: "âˆ´", Theta: "Î˜", theta: "Î¸", thetasym: "Ï‘", thetav: "Ï‘", thickapprox: "â‰ˆ", thicksim: "âˆ¼", ThickSpace: "âŸâ€Š", ThinSpace: "â€‰", thinsp: "â€‰", thkap: "â‰ˆ", thksim: "âˆ¼", THORN: "Ãž", thorn: "Ã¾", tilde: "Ëœ", Tilde: "âˆ¼", TildeEqual: "â‰ƒ", TildeFullEqual: "â‰…", TildeTilde: "â‰ˆ", timesbar: "â¨±", timesb: "âŠ ", times: "Ã—", timesd: "â¨°", tint: "âˆ­", toea: "â¤¨", topbot: "âŒ¶", topcir: "â«±", top: "âŠ¤", Topf: "ð•‹", topf: "ð•¥", topfork: "â«š", tosa: "â¤©", tprime: "â€´", trade: "â„¢", TRADE: "â„¢", triangle: "â–µ", triangledown: "â–¿", triangleleft: "â—ƒ", trianglelefteq: "âŠ´", triangleq: "â‰œ", triangleright: "â–¹", trianglerighteq: "âŠµ", tridot: "â—¬", trie: "â‰œ", triminus: "â¨º", TripleDot: "âƒ›", triplus: "â¨¹", trisb: "â§", tritime: "â¨»", trpezium: "â¢", Tscr: "ð’¯", tscr: "ð“‰", TScy: "Ð¦", tscy: "Ñ†", TSHcy: "Ð‹", tshcy: "Ñ›", Tstrok: "Å¦", tstrok: "Å§", twixt: "â‰¬", twoheadleftarrow: "â†ž", twoheadrightarrow: "â† ", Uacute: "Ãš", uacute: "Ãº", uarr: "â†‘", Uarr: "â†Ÿ", uArr: "â‡‘", Uarrocir: "â¥‰", Ubrcy: "ÐŽ", ubrcy: "Ñž", Ubreve: "Å¬", ubreve: "Å­", Ucirc: "Ã›", ucirc: "Ã»", Ucy: "Ð£", ucy: "Ñƒ", udarr: "â‡…", Udblac: "Å°", udblac: "Å±", udhar: "â¥®", ufisht: "â¥¾", Ufr: "ð”˜", ufr: "ð”²", Ugrave: "Ã™", ugrave: "Ã¹", uHar: "â¥£", uharl: "â†¿", uharr: "â†¾", uhblk: "â–€", ulcorn: "âŒœ", ulcorner: "âŒœ", ulcrop: "âŒ", ultri: "â—¸", Umacr: "Åª", umacr: "Å«", uml: "Â¨", UnderBar: "_", UnderBrace: "âŸ", UnderBracket: "âŽµ", UnderParenthesis: "â", Union: "â‹ƒ", UnionPlus: "âŠŽ", Uogon: "Å²", uogon: "Å³", Uopf: "ð•Œ", uopf: "ð•¦", UpArrowBar: "â¤’", uparrow: "â†‘", UpArrow: "â†‘", Uparrow: "â‡‘", UpArrowDownArrow: "â‡…", updownarrow: "â†•", UpDownArrow: "â†•", Updownarrow: "â‡•", UpEquilibrium: "â¥®", upharpoonleft: "â†¿", upharpoonright: "â†¾", uplus: "âŠŽ", UpperLeftArrow: "â†–", UpperRightArrow: "â†—", upsi: "Ï…", Upsi: "Ï’", upsih: "Ï’", Upsilon: "Î¥", upsilon: "Ï…", UpTeeArrow: "â†¥", UpTee: "âŠ¥", upuparrows: "â‡ˆ", urcorn: "âŒ", urcorner: "âŒ", urcrop: "âŒŽ", Uring: "Å®", uring: "Å¯", urtri: "â—¹", Uscr: "ð’°", uscr: "ð“Š", utdot: "â‹°", Utilde: "Å¨", utilde: "Å©", utri: "â–µ", utrif: "â–´", uuarr: "â‡ˆ", Uuml: "Ãœ", uuml: "Ã¼", uwangle: "â¦§", vangrt: "â¦œ", varepsilon: "Ïµ", varkappa: "Ï°", varnothing: "âˆ…", varphi: "Ï•", varpi: "Ï–", varpropto: "âˆ", varr: "â†•", vArr: "â‡•", varrho: "Ï±", varsigma: "Ï‚", varsubsetneq: "âŠŠï¸€", varsubsetneqq: "â«‹ï¸€", varsupsetneq: "âŠ‹ï¸€", varsupsetneqq: "â«Œï¸€", vartheta: "Ï‘", vartriangleleft: "âŠ²", vartriangleright: "âŠ³", vBar: "â«¨", Vbar: "â««", vBarv: "â«©", Vcy: "Ð’", vcy: "Ð²", vdash: "âŠ¢", vDash: "âŠ¨", Vdash: "âŠ©", VDash: "âŠ«", Vdashl: "â«¦", veebar: "âŠ»", vee: "âˆ¨", Vee: "â‹", veeeq: "â‰š", vellip: "â‹®", verbar: "|", Verbar: "â€–", vert: "|", Vert: "â€–", VerticalBar: "âˆ£", VerticalLine: "|", VerticalSeparator: "â˜", VerticalTilde: "â‰€", VeryThinSpace: "â€Š", Vfr: "ð”™", vfr: "ð”³", vltri: "âŠ²", vnsub: "âŠ‚âƒ’", vnsup: "âŠƒâƒ’", Vopf: "ð•", vopf: "ð•§", vprop: "âˆ", vrtri: "âŠ³", Vscr: "ð’±", vscr: "ð“‹", vsubnE: "â«‹ï¸€", vsubne: "âŠŠï¸€", vsupnE: "â«Œï¸€", vsupne: "âŠ‹ï¸€", Vvdash: "âŠª", vzigzag: "â¦š", Wcirc: "Å´", wcirc: "Åµ", wedbar: "â©Ÿ", wedge: "âˆ§", Wedge: "â‹€", wedgeq: "â‰™", weierp: "â„˜", Wfr: "ð”š", wfr: "ð”´", Wopf: "ð•Ž", wopf: "ð•¨", wp: "â„˜", wr: "â‰€", wreath: "â‰€", Wscr: "ð’²", wscr: "ð“Œ", xcap: "â‹‚", xcirc: "â—¯", xcup: "â‹ƒ", xdtri: "â–½", Xfr: "ð”›", xfr: "ð”µ", xharr: "âŸ·", xhArr: "âŸº", Xi: "Îž", xi: "Î¾", xlarr: "âŸµ", xlArr: "âŸ¸", xmap: "âŸ¼", xnis: "â‹»", xodot: "â¨€", Xopf: "ð•", xopf: "ð•©", xoplus: "â¨", xotime: "â¨‚", xrarr: "âŸ¶", xrArr: "âŸ¹", Xscr: "ð’³", xscr: "ð“", xsqcup: "â¨†", xuplus: "â¨„", xutri: "â–³", xvee: "â‹", xwedge: "â‹€", Yacute: "Ã", yacute: "Ã½", YAcy: "Ð¯", yacy: "Ñ", Ycirc: "Å¶", ycirc: "Å·", Ycy: "Ð«", ycy: "Ñ‹", yen: "Â¥", Yfr: "ð”œ", yfr: "ð”¶", YIcy: "Ð‡", yicy: "Ñ—", Yopf: "ð•", yopf: "ð•ª", Yscr: "ð’´", yscr: "ð“Ž", YUcy: "Ð®", yucy: "ÑŽ", yuml: "Ã¿", Yuml: "Å¸", Zacute: "Å¹", zacute: "Åº", Zcaron: "Å½", zcaron: "Å¾", Zcy: "Ð—", zcy: "Ð·", Zdot: "Å»", zdot: "Å¼", zeetrf: "â„¨", ZeroWidthSpace: "â€‹", Zeta: "Î–", zeta: "Î¶", zfr: "ð”·", Zfr: "â„¨", ZHcy: "Ð–", zhcy: "Ð¶", zigrarr: "â‡", zopf: "ð•«", Zopf: "â„¤", Zscr: "ð’µ", zscr: "ð“", zwj: "â€", zwnj: "â€Œ" };
  }
});
var require_legacy = __commonJS({
  "../node_modules/entities/lib/maps/legacy.json"(exports, module) {
    module.exports = { Aacute: "Ã", aacute: "Ã¡", Acirc: "Ã‚", acirc: "Ã¢", acute: "Â´", AElig: "Ã†", aelig: "Ã¦", Agrave: "Ã€", agrave: "Ã ", amp: "&", AMP: "&", Aring: "Ã…", aring: "Ã¥", Atilde: "Ãƒ", atilde: "Ã£", Auml: "Ã„", auml: "Ã¤", brvbar: "Â¦", Ccedil: "Ã‡", ccedil: "Ã§", cedil: "Â¸", cent: "Â¢", copy: "Â©", COPY: "Â©", curren: "Â¤", deg: "Â°", divide: "Ã·", Eacute: "Ã‰", eacute: "Ã©", Ecirc: "ÃŠ", ecirc: "Ãª", Egrave: "Ãˆ", egrave: "Ã¨", ETH: "Ã", eth: "Ã°", Euml: "Ã‹", euml: "Ã«", frac12: "Â½", frac14: "Â¼", frac34: "Â¾", gt: ">", GT: ">", Iacute: "Ã", iacute: "Ã­", Icirc: "ÃŽ", icirc: "Ã®", iexcl: "Â¡", Igrave: "ÃŒ", igrave: "Ã¬", iquest: "Â¿", Iuml: "Ã", iuml: "Ã¯", laquo: "Â«", lt: "<", LT: "<", macr: "Â¯", micro: "Âµ", middot: "Â·", nbsp: "Â ", not: "Â¬", Ntilde: "Ã‘", ntilde: "Ã±", Oacute: "Ã“", oacute: "Ã³", Ocirc: "Ã”", ocirc: "Ã´", Ograve: "Ã’", ograve: "Ã²", ordf: "Âª", ordm: "Âº", Oslash: "Ã˜", oslash: "Ã¸", Otilde: "Ã•", otilde: "Ãµ", Ouml: "Ã–", ouml: "Ã¶", para: "Â¶", plusmn: "Â±", pound: "Â£", quot: '"', QUOT: '"', raquo: "Â»", reg: "Â®", REG: "Â®", sect: "Â§", shy: "Â­", sup1: "Â¹", sup2: "Â²", sup3: "Â³", szlig: "ÃŸ", THORN: "Ãž", thorn: "Ã¾", times: "Ã—", Uacute: "Ãš", uacute: "Ãº", Ucirc: "Ã›", ucirc: "Ã»", Ugrave: "Ã™", ugrave: "Ã¹", uml: "Â¨", Uuml: "Ãœ", uuml: "Ã¼", Yacute: "Ã", yacute: "Ã½", yen: "Â¥", yuml: "Ã¿" };
  }
});
var require_xml = __commonJS({
  "../node_modules/entities/lib/maps/xml.json"(exports, module) {
    module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});
var require_decode = __commonJS({
  "../node_modules/entities/lib/maps/decode.json"(exports, module) {
    module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});
var require_decode_codepoint = __commonJS({
  "../node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var decode_json_1 = __importDefault(require_decode()), fromCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.fromCodePoint || function(codePoint) {
        var output = "";
        return codePoint > 65535 && (codePoint -= 65536, output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), output += String.fromCharCode(codePoint), output;
      }
    );
    function decodeCodePoint(codePoint) {
      return codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111 ? "ï¿½" : (codePoint in decode_json_1.default && (codePoint = decode_json_1.default[codePoint]), fromCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  }
});
var require_decode2 = __commonJS({
  "../node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
    var entities_json_1 = __importDefault(require_entities()), legacy_json_1 = __importDefault(require_legacy()), xml_json_1 = __importDefault(require_xml()), decode_codepoint_1 = __importDefault(require_decode_codepoint()), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    exports.decodeXML = getStrictDecoder(xml_json_1.default);
    exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map2) {
      var replace = getReplacer(map2);
      return function(str) {
        return String(str).replace(strictEntityRe, replace);
      };
    }
    var sorter = function(a, b) {
      return a < b ? 1 : -1;
    };
    exports.decodeHTML = (function() {
      for (var legacy = Object.keys(legacy_json_1.default).sort(sorter), keys = Object.keys(entities_json_1.default).sort(sorter), i = 0, j = 0; i < keys.length; i++)
        legacy[j] === keys[i] ? (keys[i] += ";?", j++) : keys[i] += ";";
      var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entities_json_1.default);
      function replacer(str) {
        return str.substr(-1) !== ";" && (str += ";"), replace(str);
      }
      return function(str) {
        return String(str).replace(re, replacer);
      };
    })();
    function getReplacer(map2) {
      return function(str) {
        if (str.charAt(1) === "#") {
          var secondChar = str.charAt(2);
          return secondChar === "X" || secondChar === "x" ? decode_codepoint_1.default(parseInt(str.substr(3), 16)) : decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        return map2[str.slice(1, -1)] || str;
      };
    }
  }
});
var require_encode = __commonJS({
  "../node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
    var xml_json_1 = __importDefault(require_xml()), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
    exports.encodeXML = getASCIIEncoder(inverseXML);
    var entities_json_1 = __importDefault(require_entities()), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
    exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name) {
        return inverse[obj[name]] = "&" + name + ";", inverse;
      }, {});
    }
    function getInverseReplacer(inverse) {
      for (var single = [], multiple = [], _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        k.length === 1 ? single.push("\\" + k) : multiple.push(k);
      }
      single.sort();
      for (var start = 0; start < single.length - 1; start++) {
        for (var end = start; end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1); )
          end += 1;
        var count2 = 1 + end - start;
        count2 < 3 || single.splice(start, count2, single[start] + "-" + single[end]);
      }
      return multiple.unshift("[" + single.join("") + "]"), new RegExp(multiple.join("|"), "g");
    }
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        (function(str) {
          return str.codePointAt(0);
        })
      ) : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        (function(c) {
          return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
        })
      )
    );
    function singleCharReplacer(c) {
      return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    function getInverse(inverse, re) {
      return function(data) {
        return data.replace(re, function(name) {
          return inverse[name];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }
    var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
    function escape(data) {
      return data.replace(reEscapeChars, singleCharReplacer);
    }
    exports.escape = escape;
    function escapeUTF8(data) {
      return data.replace(xmlReplacer, singleCharReplacer);
    }
    exports.escapeUTF8 = escapeUTF8;
    function getASCIIEncoder(obj) {
      return function(data) {
        return data.replace(reEscapeChars, function(c) {
          return obj[c] || singleCharReplacer(c);
        });
      };
    }
  }
});
var require_lib = __commonJS({
  "../node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    var decode_1 = require_decode2(), encode_1 = require_encode();
    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports.decode = decode;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports.decodeStrict = decodeStrict;
    function encode(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports.encode = encode;
    var encode_2 = require_encode();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return encode_2.encodeXML;
    } });
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return encode_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
      return encode_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    var decode_2 = require_decode2();
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
  }
});
var require_ansi_to_html = __commonJS({
  "../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length == "number") {
          it && (o = it);
          var i = 0, F = function() {
          };
          return { s: F, n: function() {
            return i >= o.length ? { done: true } : { done: false, value: o[i++] };
          }, e: function(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function() {
        it = it.call(o);
      }, n: function() {
        var step2 = it.next();
        return normalCompletion = step2.done, step2;
      }, e: function(_e2) {
        didErr = true, err = _e2;
      }, f: function() {
        try {
          !normalCompletion && it.return != null && it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (o) {
        if (typeof o == "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    var entities = require_lib(), defaults = {
      fg: "#FFF",
      bg: "#000",
      newline: false,
      escapeXML: false,
      stream: false,
      colors: getDefaultColors()
    };
    function getDefaultColors() {
      var colors3 = {
        0: "#000",
        1: "#A00",
        2: "#0A0",
        3: "#A50",
        4: "#00A",
        5: "#A0A",
        6: "#0AA",
        7: "#AAA",
        8: "#555",
        9: "#F55",
        10: "#5F5",
        11: "#FF5",
        12: "#55F",
        13: "#F5F",
        14: "#5FF",
        15: "#FFF"
      };
      return range(0, 5).forEach(function(red) {
        range(0, 5).forEach(function(green) {
          range(0, 5).forEach(function(blue) {
            return setStyleColor(red, green, blue, colors3);
          });
        });
      }), range(0, 23).forEach(function(gray) {
        var c = gray + 232, l = toHexString(gray * 10 + 8);
        colors3[c] = "#" + l + l + l;
      }), colors3;
    }
    function setStyleColor(red, green, blue, colors3) {
      var c = 16 + red * 36 + green * 6 + blue, r = red > 0 ? red * 40 + 55 : 0, g = green > 0 ? green * 40 + 55 : 0, b = blue > 0 ? blue * 40 + 55 : 0;
      colors3[c] = toColorHexString([r, g, b]);
    }
    function toHexString(num) {
      for (var str = num.toString(16); str.length < 2; )
        str = "0" + str;
      return str;
    }
    function toColorHexString(ref) {
      var results = [], _iterator = _createForOfIteratorHelper(ref), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var r = _step.value;
          results.push(toHexString(r));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return "#" + results.join("");
    }
    function generateOutput(stack, token, data, options) {
      var result;
      return token === "text" ? result = pushText(data, options) : token === "display" ? result = handleDisplay(stack, data, options) : token === "xterm256Foreground" ? result = pushForegroundColor(stack, options.colors[data]) : token === "xterm256Background" ? result = pushBackgroundColor(stack, options.colors[data]) : token === "rgb" && (result = handleRgb(stack, data)), result;
    }
    function handleRgb(stack, data) {
      data = data.substring(2).slice(0, -1);
      var operation = +data.substr(0, 2), color = data.substring(5).split(";"), rgb = color.map(function(value) {
        return ("0" + Number(value).toString(16)).substr(-2);
      }).join("");
      return pushStyle(stack, (operation === 38 ? "color:#" : "background-color:#") + rgb);
    }
    function handleDisplay(stack, code, options) {
      code = parseInt(code, 10);
      var codeMap = {
        "-1": function() {
          return "<br/>";
        },
        0: function() {
          return stack.length && resetStyles(stack);
        },
        1: function() {
          return pushTag(stack, "b");
        },
        3: function() {
          return pushTag(stack, "i");
        },
        4: function() {
          return pushTag(stack, "u");
        },
        8: function() {
          return pushStyle(stack, "display:none");
        },
        9: function() {
          return pushTag(stack, "strike");
        },
        22: function() {
          return pushStyle(stack, "font-weight:normal;text-decoration:none;font-style:normal");
        },
        23: function() {
          return closeTag(stack, "i");
        },
        24: function() {
          return closeTag(stack, "u");
        },
        39: function() {
          return pushForegroundColor(stack, options.fg);
        },
        49: function() {
          return pushBackgroundColor(stack, options.bg);
        },
        53: function() {
          return pushStyle(stack, "text-decoration:overline");
        }
      }, result;
      return codeMap[code] ? result = codeMap[code]() : 4 < code && code < 7 ? result = pushTag(stack, "blink") : 29 < code && code < 38 ? result = pushForegroundColor(stack, options.colors[code - 30]) : 39 < code && code < 48 ? result = pushBackgroundColor(stack, options.colors[code - 40]) : 89 < code && code < 98 ? result = pushForegroundColor(stack, options.colors[8 + (code - 90)]) : 99 < code && code < 108 && (result = pushBackgroundColor(stack, options.colors[8 + (code - 100)])), result;
    }
    function resetStyles(stack) {
      var stackClone = stack.slice(0);
      return stack.length = 0, stackClone.reverse().map(function(tag) {
        return "</" + tag + ">";
      }).join("");
    }
    function range(low, high) {
      for (var results = [], j = low; j <= high; j++)
        results.push(j);
      return results;
    }
    function notCategory(category) {
      return function(e) {
        return (category === null || e.category !== category) && category !== "all";
      };
    }
    function categoryForCode(code) {
      code = parseInt(code, 10);
      var result = null;
      return code === 0 ? result = "all" : code === 1 ? result = "bold" : 2 < code && code < 5 ? result = "underline" : 4 < code && code < 7 ? result = "blink" : code === 8 ? result = "hide" : code === 9 ? result = "strike" : 29 < code && code < 38 || code === 39 || 89 < code && code < 98 ? result = "foreground-color" : (39 < code && code < 48 || code === 49 || 99 < code && code < 108) && (result = "background-color"), result;
    }
    function pushText(text, options) {
      return options.escapeXML ? entities.encodeXML(text) : text;
    }
    function pushTag(stack, tag, style) {
      return style || (style = ""), stack.push(tag), "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
    }
    function pushStyle(stack, style) {
      return pushTag(stack, "span", style);
    }
    function pushForegroundColor(stack, color) {
      return pushTag(stack, "span", "color:" + color);
    }
    function pushBackgroundColor(stack, color) {
      return pushTag(stack, "span", "background-color:" + color);
    }
    function closeTag(stack, style) {
      var last;
      if (stack.slice(-1)[0] === style && (last = stack.pop()), last)
        return "</" + style + ">";
    }
    function tokenize(text, options, callback) {
      var ansiMatch = false, ansiHandler = 3;
      function remove() {
        return "";
      }
      function removeXterm256Foreground(m, g1) {
        return callback("xterm256Foreground", g1), "";
      }
      function removeXterm256Background(m, g1) {
        return callback("xterm256Background", g1), "";
      }
      function newline(m) {
        return options.newline ? callback("display", -1) : callback("text", m), "";
      }
      function ansiMess(m, g1) {
        ansiMatch = true, g1.trim().length === 0 && (g1 = "0"), g1 = g1.trimRight(";").split(";");
        var _iterator2 = _createForOfIteratorHelper(g1), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var g = _step2.value;
            callback("display", g);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return "";
      }
      function realText(m) {
        return callback("text", m), "";
      }
      function rgb(m) {
        return callback("rgb", m), "";
      }
      var tokens = [{
        pattern: /^\x08+/,
        sub: remove
      }, {
        pattern: /^\x1b\[[012]?K/,
        sub: remove
      }, {
        pattern: /^\x1b\[\(B/,
        sub: remove
      }, {
        pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
        sub: rgb
      }, {
        pattern: /^\x1b\[38;5;(\d+)m/,
        sub: removeXterm256Foreground
      }, {
        pattern: /^\x1b\[48;5;(\d+)m/,
        sub: removeXterm256Background
      }, {
        pattern: /^\n/,
        sub: newline
      }, {
        pattern: /^\r+\n/,
        sub: newline
      }, {
        pattern: /^\r/,
        sub: newline
      }, {
        pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
        sub: ansiMess
      }, {
        // CSI n J
        // ED - Erase in Display Clears part of the screen.
        // If n is 0 (or missing), clear from cursor to end of screen.
        // If n is 1, clear from cursor to beginning of the screen.
        // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
        // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
        //   (this feature was added for xterm and is supported by other terminal applications).
        pattern: /^\x1b\[\d?J/,
        sub: remove
      }, {
        // CSI n ; m f
        // HVP - Horizontal Vertical Position Same as CUP
        pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
        sub: remove
      }, {
        // catch-all for CSI sequences?
        pattern: /^\x1b\[?[\d;]{0,3}/,
        sub: remove
      }, {
        /**
         * extracts real text - not containing:
         * - `\x1b' - ESC - escape (Ascii 27)
         * - '\x08' - BS - backspace (Ascii 8)
         * - `\n` - Newline - linefeed (LF) (ascii 10)
         * - `\r` - Windows Carriage Return (CR)
         */
        pattern: /^(([^\x1b\x08\r\n])+)/,
        sub: realText
      }];
      function process(handler2, i2) {
        i2 > ansiHandler && ansiMatch || (ansiMatch = false, text = text.replace(handler2.pattern, handler2.sub));
      }
      var results1 = [], _text = text, length = _text.length;
      outer: for (; length > 0; ) {
        for (var i = 0, o = 0, len = tokens.length; o < len; i = ++o) {
          var handler = tokens[i];
          if (process(handler, i), text.length !== length) {
            length = text.length;
            continue outer;
          }
        }
        if (text.length === length)
          break;
        results1.push(0), length = text.length;
      }
      return results1;
    }
    function updateStickyStack(stickyStack, token, data) {
      return token !== "text" && (stickyStack = stickyStack.filter(notCategory(categoryForCode(data))), stickyStack.push({
        token,
        data,
        category: categoryForCode(data)
      })), stickyStack;
    }
    var Filter = (function() {
      function Filter2(options) {
        _classCallCheck(this, Filter2), options = options || {}, options.colors && (options.colors = Object.assign({}, defaults.colors, options.colors)), this.options = Object.assign({}, defaults, options), this.stack = [], this.stickyStack = [];
      }
      return _createClass(Filter2, [{
        key: "toHtml",
        value: function(input) {
          var _this = this;
          input = typeof input == "string" ? [input] : input;
          var stack = this.stack, options = this.options, buf = [];
          return this.stickyStack.forEach(function(element) {
            var output = generateOutput(stack, element.token, element.data, options);
            output && buf.push(output);
          }), tokenize(input.join(""), options, function(token, data) {
            var output = generateOutput(stack, token, data, options);
            output && buf.push(output), options.stream && (_this.stickyStack = updateStickyStack(_this.stickyStack, token, data));
          }), stack.length && buf.push(resetStyles(stack)), buf.join("");
        }
      }]), Filter2;
    })();
    module.exports = Filter;
  }
});

// node_modules/storybook/dist/_browser-chunks/chunk-FNXWN6IK.js
var ADDON_ID2 = "storybook/background";
var PARAM_KEY = "backgrounds";
var EVENTS = {
  UPDATE: `${ADDON_ID2}/update`
};
var ADDON_ID22 = "storybook/measure-addon";
var TOOL_ID = `${ADDON_ID22}/tool`;
var PARAM_KEY2 = "measureEnabled";
var EVENTS2 = {
  RESULT: `${ADDON_ID22}/result`,
  REQUEST: `${ADDON_ID22}/request`,
  CLEAR: `${ADDON_ID22}/clear`
};
var PARAM_KEY3 = "outline";
var DEFAULT_BACKGROUNDS = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
};

// node_modules/storybook/dist/_browser-chunks/chunk-KJHJLCBK.js
var ADDON_ID3 = "storybook/highlight";
var HIGHLIGHT = `${ADDON_ID3}/add`;
var REMOVE_HIGHLIGHT = `${ADDON_ID3}/remove`;
var RESET_HIGHLIGHT = `${ADDON_ID3}/reset`;
var SCROLL_INTO_VIEW = `${ADDON_ID3}/scroll-into-view`;
var MAX_Z_INDEX = 2147483647;
var MIN_TOUCH_AREA_SIZE = 28;

// node_modules/storybook/dist/_browser-chunks/chunk-6XWLIJQL.js
var ADDON_ID4 = "storybook/actions";
var PANEL_ID2 = `${ADDON_ID4}/panel`;
var EVENT_ID = `${ADDON_ID4}/action-event`;
var CLEAR_ID = `${ADDON_ID4}/action-clear`;

// node_modules/storybook/dist/_browser-chunks/chunk-EUVGDK4H.js
var config = {
  depth: 10,
  clearOnStoryChange: true,
  limit: 50
};
var findProto = (obj, callback) => {
  let proto = Object.getPrototypeOf(obj);
  return !proto || callback(proto) ? proto : findProto(proto, callback);
};
var isReactSyntheticEvent = (e) => !!(typeof e == "object" && e && findProto(e, (proto) => /^Synthetic(?:Base)?Event$/.test(proto.constructor.name)) && typeof e.persist == "function");
var serializeArg = (a) => {
  if (isReactSyntheticEvent(a)) {
    let e = Object.create(
      a.constructor.prototype,
      Object.getOwnPropertyDescriptors(a)
    );
    e.persist();
    let viewDescriptor = Object.getOwnPropertyDescriptor(e, "view"), view = viewDescriptor?.value;
    return typeof view == "object" && view?.constructor.name === "Window" && Object.defineProperty(e, "view", {
      ...viewDescriptor,
      value: Object.create(view.constructor.prototype)
    }), e;
  }
  return a;
};
function action(name, options = {}) {
  let actionOptions = {
    ...config,
    ...options
  }, handler = function(...args) {
    if (options.implicit) {
      let storyRenderer = ("__STORYBOOK_PREVIEW__" in scope ? scope.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
        (render) => render.phase === "playing" || render.phase === "rendering"
      );
      if (storyRenderer) {
        let deprecated = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, error = new ImplicitActionsDuringRendering({
          phase: storyRenderer.phase,
          name,
          deprecated
        });
        if (deprecated)
          console.warn(error);
        else
          throw error;
      }
    }
    let channel = addons.getChannel(), id = Date.now().toString(36) + Math.random().toString(36).substring(2), minDepth = 5, serializedArgs = args.map(serializeArg), normalizedArgs = args.length > 1 ? serializedArgs : serializedArgs[0], actionDisplayToEmit = {
      id,
      count: 0,
      data: { name, args: normalizedArgs },
      options: {
        ...actionOptions,
        maxDepth: minDepth + (actionOptions.depth || 3)
      }
    };
    channel.emit(EVENT_ID, actionDisplayToEmit);
  };
  return handler.isAction = true, handler.implicit = options.implicit, handler;
}

// node_modules/storybook/dist/_browser-chunks/chunk-SL75JR6Y.js
var ADDON_ID5 = "storybook/viewport";
var PARAM_KEY4 = "viewport";
var PANEL_ID3 = `${ADDON_ID5}/panel`;
var TOOL_ID2 = `${ADDON_ID5}/tool`;

// node_modules/storybook/dist/csf/index.js
var require_tiny_isequal = __commonJS({
  "../node_modules/@ngard/tiny-isequal/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true }), exports.isEqual = /* @__PURE__ */ (function() {
      var e = Object.prototype.toString, r = Object.getPrototypeOf, t = Object.getOwnPropertySymbols ? function(e2) {
        return Object.keys(e2).concat(Object.getOwnPropertySymbols(e2));
      } : Object.keys;
      return function(n, a) {
        return (function n2(a2, c, u) {
          var i, s, l, o = e.call(a2), f = e.call(c);
          if (a2 === c) return true;
          if (a2 == null || c == null) return false;
          if (u.indexOf(a2) > -1 && u.indexOf(c) > -1) return true;
          if (u.push(a2, c), o != f || (i = t(a2), s = t(c), i.length != s.length || i.some(function(e2) {
            return !n2(a2[e2], c[e2], u);
          }))) return false;
          switch (o.slice(8, -1)) {
            case "Symbol":
              return a2.valueOf() == c.valueOf();
            case "Date":
            case "Number":
              return +a2 == +c || +a2 != +a2 && +c != +c;
            case "RegExp":
            case "Function":
            case "String":
            case "Boolean":
              return "" + a2 == "" + c;
            case "Set":
            case "Map":
              i = a2.entries(), s = c.entries();
              do
                if (!n2((l = i.next()).value, s.next().value, u)) return false;
              while (!l.done);
              return true;
            case "ArrayBuffer":
              a2 = new Uint8Array(a2), c = new Uint8Array(c);
            case "DataView":
              a2 = new Uint8Array(a2.buffer), c = new Uint8Array(c.buffer);
            case "Float32Array":
            case "Float64Array":
            case "Int8Array":
            case "Int16Array":
            case "Int32Array":
            case "Uint8Array":
            case "Uint16Array":
            case "Uint32Array":
            case "Uint8ClampedArray":
            case "Arguments":
            case "Array":
              if (a2.length != c.length) return false;
              for (l = 0; l < a2.length; l++) if ((l in a2 || l in c) && (l in a2 != l in c || !n2(a2[l], c[l], u))) return false;
              return true;
            case "Object":
              return n2(r(a2), r(c), u);
            default:
              return false;
          }
        })(n, a, []);
      };
    })();
  }
});
function toStartCaseStr(str) {
  return str.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (str2, $1, $2, $3) => `${$1} ${$2}${$3}`).replace(/([a-z])([A-Z])/g, (str2, $1, $2) => `${$1} ${$2}`).replace(/([a-z])([0-9])/gi, (str2, $1, $2) => `${$1} ${$2}`).replace(/([0-9])([a-z])/gi, (str2, $1, $2) => `${$1} ${$2}`).replace(/(\s|^)(\w)/g, (str2, $1, $2) => `${$1}${$2.toUpperCase()}`).replace(/ +/g, " ").trim();
}
var import_tiny_isequal = __toESM(require_tiny_isequal(), 1);
var count = (vals) => vals.map((v) => typeof v < "u").filter(Boolean).length;
var testValue = (cond, value) => {
  let { exists, eq: eq2, neq, truthy } = cond;
  if (count([exists, eq2, neq, truthy]) > 1)
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq: eq2, neq })}`);
  if (typeof eq2 < "u")
    return (0, import_tiny_isequal.isEqual)(value, eq2);
  if (typeof neq < "u")
    return !(0, import_tiny_isequal.isEqual)(value, neq);
  if (typeof exists < "u") {
    let valueExists = typeof value < "u";
    return exists ? valueExists : !valueExists;
  }
  return (typeof truthy > "u" ? true : truthy) ? !!value : !value;
};
var includeConditionalArg = (argType, args, globals) => {
  if (!argType.if)
    return true;
  let { arg, global: global5 } = argType.if;
  if (count([arg, global5]) !== 1)
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global: global5 })}`);
  let value = arg ? args[arg] : globals[global5];
  return testValue(argType.if, value);
};
var addArgs_exports = {};
__export(addArgs_exports, {
  argsEnhancers: () => argsEnhancers
});
var isInInitialArgs = (name, initialArgs) => typeof initialArgs[name] > "u" && !(name in initialArgs);
var inferActionsFromArgTypesRegex = (context) => {
  let {
    initialArgs,
    argTypes,
    id,
    parameters: { actions }
  } = context;
  if (!actions || actions.disable || !actions.argTypesRegex || !argTypes)
    return {};
  let argTypesRegex = new RegExp(actions.argTypesRegex);
  return Object.entries(argTypes).filter(
    ([name]) => !!argTypesRegex.test(name)
  ).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(name, { implicit: true, id })), acc), {});
};
var addActionsFromArgTypes = (context) => {
  let {
    initialArgs,
    argTypes,
    parameters: { actions }
  } = context;
  return actions?.disable || !argTypes ? {} : Object.entries(argTypes).filter(([name, argType]) => !!argType.action).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(typeof argType.action == "string" ? argType.action : name)), acc), {});
};
var argsEnhancers = [
  addActionsFromArgTypes,
  inferActionsFromArgTypesRegex
];
var loaders_exports = {};
__export(loaders_exports, {
  loaders: () => loaders
});
var subscribed = false;
var logActionsWhenMockCalled = (context) => {
  let { parameters: parameters2 } = context;
  parameters2?.actions?.disable || subscribed || (onMockCall((mock, args) => {
    let name = mock.getMockName();
    name !== "spy" && name !== "vi.fn()" && (!/^next\/.*::/.test(name) || [
      "next/router::useRouter()",
      "next/navigation::useRouter()",
      "next/navigation::redirect",
      "next/cache::",
      "next/headers::cookies().set",
      "next/headers::cookies().delete",
      "next/headers::headers().set",
      "next/headers::headers().delete"
    ].some((prefix) => name.startsWith(prefix))) && action(name)(args);
  }), subscribed = true);
};
var loaders = [logActionsWhenMockCalled];
var preview_default = () => definePreviewAddon9({
  ...addArgs_exports,
  ...loaders_exports
});
var { document: document2 } = globalThis;
var isReduceMotionEnabled = () => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : false;
var clearStyles = (selector) => {
  (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle);
};
var clearStyle = (selector) => {
  if (!document2)
    return;
  let element = document2.getElementById(selector);
  element && element.parentElement && element.parentElement.removeChild(element);
};
var addGridStyle = (selector, css) => {
  if (!document2)
    return;
  let existingStyle = document2.getElementById(selector);
  if (existingStyle)
    existingStyle.innerHTML !== css && (existingStyle.innerHTML = css);
  else {
    let style = document2.createElement("style");
    style.setAttribute("id", selector), style.innerHTML = css, document2.head.appendChild(style);
  }
};
var addBackgroundStyle = (selector, css, storyId) => {
  if (!document2)
    return;
  let existingStyle = document2.getElementById(selector);
  if (existingStyle)
    existingStyle.innerHTML !== css && (existingStyle.innerHTML = css);
  else {
    let style = document2.createElement("style");
    style.setAttribute("id", selector), style.innerHTML = css;
    let gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : ""}`, existingGridStyle = document2.getElementById(gridStyleSelector);
    existingGridStyle ? existingGridStyle.parentElement?.insertBefore(style, existingGridStyle) : document2.head.appendChild(style);
  }
};
var defaultGrid = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
};
var BG_SELECTOR_BASE = "addon-backgrounds";
var GRID_SELECTOR_BASE = "addon-backgrounds-grid";
var transitionStyle = isReduceMotionEnabled() ? "" : "transition: background-color 0.3s;";
var withBackgroundAndGrid = (StoryFn, context) => {
  let { globals = {}, parameters: parameters2 = {}, viewMode, id } = context, {
    options = DEFAULT_BACKGROUNDS,
    disable,
    grid = defaultGrid
  } = parameters2[PARAM_KEY] || {}, data = globals[PARAM_KEY] || {}, backgroundName = typeof data == "string" ? data : data?.value, item = backgroundName ? options[backgroundName] : void 0, value = typeof item == "string" ? item : item?.value || "transparent", showGrid = typeof data == "string" ? false : data.grid || false, shownBackground = !!item && !disable, backgroundSelector = viewMode === "docs" ? `#anchor--${id} .docs-story` : ".sb-show-main", gridSelector = viewMode === "docs" ? `#anchor--${id} .docs-story` : ".sb-show-main", isLayoutPadded = parameters2.layout === void 0 || parameters2.layout === "padded", defaultOffset = viewMode === "docs" ? 20 : isLayoutPadded ? 16 : 0, { cellAmount, cellSize, opacity, offsetX = defaultOffset, offsetY = defaultOffset } = grid, backgroundSelectorId = viewMode === "docs" ? `${BG_SELECTOR_BASE}-docs-${id}` : `${BG_SELECTOR_BASE}-color`, backgroundTarget = viewMode === "docs" ? id : null;
  useEffect(() => {
    let backgroundStyles = `
    ${backgroundSelector} {
      background: ${value} !important;
      ${transitionStyle}
      }`;
    if (!shownBackground) {
      clearStyles(backgroundSelectorId);
      return;
    }
    addBackgroundStyle(backgroundSelectorId, backgroundStyles, backgroundTarget);
  }, [backgroundSelector, backgroundSelectorId, backgroundTarget, shownBackground, value]);
  let gridSelectorId = viewMode === "docs" ? `${GRID_SELECTOR_BASE}-docs-${id}` : `${GRID_SELECTOR_BASE}`;
  return useEffect(() => {
    if (!showGrid) {
      clearStyles(gridSelectorId);
      return;
    }
    let gridSize = [
      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
      `${cellSize}px ${cellSize}px`,
      `${cellSize}px ${cellSize}px`
    ].join(", "), gridStyles = `
        ${gridSelector} {
          background-size: ${gridSize} !important;
          background-position: ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px) !important;
        }
      `;
    addGridStyle(gridSelectorId, gridStyles);
  }, [cellAmount, cellSize, gridSelector, gridSelectorId, showGrid, offsetX, offsetY, opacity]), StoryFn();
};
var decorators = globalThis.FEATURES?.backgrounds ? [withBackgroundAndGrid] : [];
var parameters = {
  [PARAM_KEY]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: false
  }
};
var initialGlobals = {
  [PARAM_KEY]: { value: void 0, grid: false }
};
var preview_default2 = () => definePreviewAddon9({
  decorators,
  parameters,
  initialGlobals
});
var { step } = instrument(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: async (label, play, context) => play(context)
  },
  { intercept: true }
);
var preview_default3 = () => definePreviewAddon9({
  parameters: {
    throwPlayFunctionExceptions: false
  },
  runStep: step
});
var iconPaths = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
};
var svgElements = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(",");
var createElement = (type, props = {}, children) => {
  let element = svgElements.includes(type) ? document.createElementNS("http://www.w3.org/2000/svg", type) : document.createElement(type);
  return Object.entries(props).forEach(([key, val]) => {
    /[A-Z]/.test(key) ? (key === "onClick" && (element.addEventListener("click", val), element.addEventListener("keydown", (e) => {
      (e.key === "Enter" || e.key === " ") && (e.preventDefault(), val());
    })), key === "onMouseEnter" && element.addEventListener("mouseenter", val), key === "onMouseLeave" && element.addEventListener("mouseleave", val)) : element.setAttribute(key, val);
  }), children?.forEach((child) => {
    if (!(child == null || child === false))
      try {
        element.appendChild(child);
      } catch {
        element.appendChild(document.createTextNode(String(child)));
      }
  }), element;
};
var createIcon = (name) => iconPaths[name] && createElement(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  iconPaths[name].map(
    (d) => createElement("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d
    })
  )
);
var normalizeOptions = (options) => {
  if ("elements" in options) {
    let { elements, color, style } = options;
    return {
      id: void 0,
      priority: 0,
      selectors: elements,
      styles: {
        outline: `2px ${style} ${color}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  let { menu, ...rest } = options;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...rest,
    menu: Array.isArray(menu) ? menu.every(Array.isArray) ? menu : [menu] : void 0
  };
};
var isFunction = (obj) => obj instanceof Function;
var state = /* @__PURE__ */ new Map();
var listeners = /* @__PURE__ */ new Map();
var teardowns = /* @__PURE__ */ new Map();
var useStore = (initialValue) => {
  let key = /* @__PURE__ */ Symbol();
  return listeners.set(key, []), state.set(key, initialValue), { get: () => state.get(key), set: (update) => {
    let current = state.get(key), next = isFunction(update) ? update(current) : update;
    next !== current && (state.set(key, next), listeners.get(key)?.forEach((listener) => {
      teardowns.get(listener)?.(), teardowns.set(listener, listener(next));
    }));
  }, subscribe: (listener) => (listeners.get(key)?.push(listener), () => {
    let list = listeners.get(key);
    list && listeners.set(
      key,
      list.filter((l) => l !== listener)
    );
  }), teardown: () => {
    listeners.get(key)?.forEach((listener) => {
      teardowns.get(listener)?.(), teardowns.delete(listener);
    }), listeners.delete(key), state.delete(key);
  } };
};
var mapElements = (highlights) => {
  let root = document.getElementById("storybook-root"), map2 = /* @__PURE__ */ new Map();
  for (let highlight of highlights) {
    let { priority = 0 } = highlight;
    for (let selector of highlight.selectors) {
      let elements = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${selector}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...root?.querySelectorAll(selector) || []
      ];
      for (let element of elements) {
        let existing = map2.get(element);
        (!existing || existing.priority <= priority) && map2.set(element, {
          ...highlight,
          priority,
          selectors: Array.from(new Set((existing?.selectors || []).concat(selector)))
        });
      }
    }
  }
  return map2;
};
var mapBoxes = (elements) => Array.from(elements.entries()).map(([element, { selectors, styles, hoverStyles, focusStyles, menu }]) => {
  let { top, left, width, height } = element.getBoundingClientRect(), { position } = getComputedStyle(element);
  return {
    element,
    selectors,
    styles,
    hoverStyles,
    focusStyles,
    menu,
    top: position === "fixed" ? top : top + window.scrollY,
    left: position === "fixed" ? left : left + window.scrollX,
    width,
    height
  };
}).sort((a, b) => b.width * b.height - a.width * a.height);
var isOverMenu = (menuElement, coordinates) => {
  let menu = menuElement.getBoundingClientRect(), { x, y } = coordinates;
  return menu?.top && menu?.left && x >= menu.left && x <= menu.left + menu.width && y >= menu.top && y <= menu.top + menu.height;
};
var isTargeted = (box, boxElement, coordinates) => {
  if (!boxElement || !coordinates)
    return false;
  let { left, top, width, height } = box;
  height < MIN_TOUCH_AREA_SIZE && (top = top - Math.round((MIN_TOUCH_AREA_SIZE - height) / 2), height = MIN_TOUCH_AREA_SIZE), width < MIN_TOUCH_AREA_SIZE && (left = left - Math.round((MIN_TOUCH_AREA_SIZE - width) / 2), width = MIN_TOUCH_AREA_SIZE), boxElement.style.position === "fixed" && (left += window.scrollX, top += window.scrollY);
  let { x, y } = coordinates;
  return x >= left && x <= left + width && y >= top && y <= top + height;
};
var keepInViewport = (element, targetCoordinates, options = {}) => {
  let { x, y } = targetCoordinates, { margin = 5, topOffset = 0, centered = false } = options, { scrollX, scrollY, innerHeight: windowHeight, innerWidth: windowWidth } = window, top = Math.min(
    element.style.position === "fixed" ? y - scrollY : y,
    windowHeight - element.clientHeight - margin - topOffset + scrollY
  ), leftOffset = centered ? element.clientWidth / 2 : 0, left = element.style.position === "fixed" ? Math.max(Math.min(x - scrollX, windowWidth - leftOffset - margin), leftOffset + margin) : Math.max(
    Math.min(x, windowWidth - leftOffset - margin + scrollX),
    leftOffset + margin + scrollX
  );
  Object.assign(element.style, {
    ...left !== x && { left: `${left}px` },
    ...top !== y && { top: `${top}px` }
  });
};
var showPopover = (element) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.showPopover();
};
var hidePopover = (element) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.hidePopover();
};
var getEventDetails = (target) => ({
  top: target.top,
  left: target.left,
  width: target.width,
  height: target.height,
  selectors: target.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(target.element.attributes).map((attr) => [attr.name, attr.value])
    ),
    localName: target.element.localName,
    tagName: target.element.tagName,
    outerHTML: target.element.outerHTML
  }
});
var menuId = "storybook-highlights-menu";
var rootId = "storybook-highlights-root";
var storybookRootId = "storybook-root";
var useHighlights = (channel) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
    return;
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = true;
  let { document: document32 } = globalThis, highlights = useStore([]), elements = useStore(/* @__PURE__ */ new Map()), boxes = useStore([]), clickCoords = useStore(), hoverCoords = useStore(), targets = useStore([]), hovered = useStore([]), focused = useStore(), selected = useStore(), root = document32.getElementById(rootId);
  highlights.subscribe(() => {
    root || (root = createElement("div", { id: rootId }), document32.body.appendChild(root));
  }), highlights.subscribe((value) => {
    let storybookRoot = document32.getElementById(storybookRootId);
    if (!storybookRoot)
      return;
    elements.set(mapElements(value));
    let observer = new MutationObserver(() => elements.set(mapElements(value)));
    return observer.observe(storybookRoot, { subtree: true, childList: true }), () => {
      observer.disconnect();
    };
  }), elements.subscribe((value) => {
    let updateBoxes = () => requestAnimationFrame(() => boxes.set(mapBoxes(value))), observer = new ResizeObserver(updateBoxes);
    observer.observe(document32.body), Array.from(value.keys()).forEach((element) => observer.observe(element));
    let scrollers = Array.from(document32.body.querySelectorAll("*")).filter((el) => {
      let { overflow, overflowX, overflowY } = window.getComputedStyle(el);
      return ["auto", "scroll"].some((o) => [overflow, overflowX, overflowY].includes(o));
    });
    return scrollers.forEach((element) => element.addEventListener("scroll", updateBoxes)), () => {
      observer.disconnect(), scrollers.forEach((element) => element.removeEventListener("scroll", updateBoxes));
    };
  }), elements.subscribe((value) => {
    let sticky = Array.from(value.keys()).filter(({ style }) => style.position === "sticky"), updateBoxes = () => requestAnimationFrame(() => {
      boxes.set(
        (current) => current.map((box) => {
          if (sticky.includes(box.element)) {
            let { top, left } = box.element.getBoundingClientRect();
            return { ...box, top: top + window.scrollY, left: left + window.scrollX };
          }
          return box;
        })
      );
    });
    return document32.addEventListener("scroll", updateBoxes), () => document32.removeEventListener("scroll", updateBoxes);
  }), elements.subscribe((value) => {
    targets.set((t) => t.filter(({ element }) => value.has(element)));
  }), targets.subscribe((value) => {
    value.length ? (selected.set((s) => value.some((t) => t.element === s?.element) ? s : void 0), focused.set((s) => value.some((t) => t.element === s?.element) ? s : void 0)) : (selected.set(void 0), focused.set(void 0), clickCoords.set(void 0));
  });
  let styleElementByHighlight = new Map(/* @__PURE__ */ new Map());
  highlights.subscribe((value) => {
    value.forEach(({ keyframes }) => {
      if (keyframes) {
        let style = styleElementByHighlight.get(keyframes);
        style || (style = document32.createElement("style"), style.setAttribute("data-highlight", "keyframes"), styleElementByHighlight.set(keyframes, style), document32.head.appendChild(style)), style.innerHTML = keyframes;
      }
    }), styleElementByHighlight.forEach((style, keyframes) => {
      value.some((v) => v.keyframes === keyframes) || (style.remove(), styleElementByHighlight.delete(keyframes));
    });
  });
  let boxElementByTargetElement = new Map(/* @__PURE__ */ new Map());
  boxes.subscribe((value) => {
    value.forEach((box) => {
      let boxElement = boxElementByTargetElement.get(box.element);
      if (root && !boxElement) {
        let props = {
          popover: "manual",
          "data-highlight-dimensions": `w${box.width.toFixed(0)}h${box.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${box.left.toFixed(0)}y${box.top.toFixed(0)}`
        };
        boxElement = root.appendChild(
          createElement("div", props, [createElement("div")])
        ), boxElementByTargetElement.set(box.element, boxElement);
      }
    }), boxElementByTargetElement.forEach((box, element) => {
      value.some(({ element: e }) => e === element) || (box.remove(), boxElementByTargetElement.delete(element));
    });
  }), boxes.subscribe((value) => {
    let targetable = value.filter((box) => box.menu);
    if (!targetable.length)
      return;
    let onClick = (event) => {
      requestAnimationFrame(() => {
        let menu = document32.getElementById(menuId), coords = { x: event.pageX, y: event.pageY };
        if (menu && !isOverMenu(menu, coords)) {
          let results = targetable.filter((box) => {
            let boxElement = boxElementByTargetElement.get(box.element);
            return isTargeted(box, boxElement, coords);
          });
          clickCoords.set(results.length ? coords : void 0), targets.set(results);
        }
      });
    };
    return document32.addEventListener("click", onClick), () => document32.removeEventListener("click", onClick);
  });
  let updateHovered = () => {
    let menu = document32.getElementById(menuId), coords = hoverCoords.get();
    !coords || menu && isOverMenu(menu, coords) || hovered.set((current) => {
      let update = boxes.get().filter((box) => {
        let boxElement = boxElementByTargetElement.get(box.element);
        return isTargeted(box, boxElement, coords);
      }), existing = current.filter((box) => update.includes(box)), additions = update.filter((box) => !current.includes(box)), hasRemovals = current.length - existing.length;
      return additions.length || hasRemovals ? [...existing, ...additions] : current;
    });
  };
  hoverCoords.subscribe(updateHovered), boxes.subscribe(updateHovered);
  let updateBoxStyles = () => {
    let selectedElement = selected.get(), targetElements = selectedElement ? [selectedElement] : targets.get(), focusedElement = targetElements.length === 1 ? targetElements[0] : focused.get(), isMenuOpen = clickCoords.get() !== void 0;
    boxes.get().forEach((box) => {
      let boxElement = boxElementByTargetElement.get(box.element);
      if (boxElement) {
        let isFocused = focusedElement === box, isHovered = isMenuOpen ? focusedElement ? isFocused : targetElements.includes(box) : hovered.get()?.includes(box);
        Object.assign(boxElement.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...box.styles,
          ...isHovered ? box.hoverStyles : {},
          ...isFocused ? box.focusStyles : {},
          position: getComputedStyle(box.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: MAX_Z_INDEX - 10,
          top: `${box.top}px`,
          left: `${box.left}px`,
          width: `${box.width}px`,
          height: `${box.height}px`,
          margin: 0,
          padding: 0,
          cursor: box.menu && isHovered ? "pointer" : "default",
          pointerEvents: box.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        }), Object.assign(boxElement.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${MIN_TOUCH_AREA_SIZE}px`,
          minWidth: `${MIN_TOUCH_AREA_SIZE}px`,
          boxSizing: "content-box",
          padding: boxElement.style.outlineWidth || "0px"
        }), showPopover(boxElement);
      }
    });
  };
  boxes.subscribe(updateBoxStyles), targets.subscribe(updateBoxStyles), hovered.subscribe(updateBoxStyles), focused.subscribe(updateBoxStyles), selected.subscribe(updateBoxStyles);
  let renderMenu = () => {
    if (!root)
      return;
    let menu = document32.getElementById(menuId);
    if (menu)
      menu.innerHTML = "";
    else {
      let props = { id: menuId, popover: "manual" };
      menu = root.appendChild(createElement("div", props)), root.appendChild(
        createElement("style", {}, [
          `
            #${menuId} {
              position: absolute;
              z-index: ${MAX_Z_INDEX};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${menuId} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${menuId} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${menuId} li {
              padding: 0 4px;
              margin: 0;
            }
            #${menuId} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${menuId} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${menuId} button:focus-visible {
              outline-color: #029CFD;
            }
            #${menuId} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${menuId} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${menuId} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${menuId} li > button:hover svg, #${menuId} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${menuId} .element-list li svg {
              display: none;
            }
            #${menuId} li.selectable svg, #${menuId} li.selected svg {
              display: block;
            }
            #${menuId} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-items, #${menuId} .menu-items li {
              padding: 0;
            }
            #${menuId} .menu-item {
              display: flex;
            }
            #${menuId} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    let selectedElement = selected.get(), elementList = selectedElement ? [selectedElement] : targets.get();
    if (elementList.length && (menu.style.position = getComputedStyle(elementList[0].element).position === "fixed" ? "fixed" : "absolute", menu.appendChild(
      createElement(
        "ul",
        { class: "element-list" },
        elementList.map((target) => {
          let selectable = elementList.length > 1 && !!target.menu?.some(
            (group) => group.some(
              (item) => !item.selectors || item.selectors.some((s) => target.selectors.includes(s))
            )
          ), props = selectable ? {
            class: "selectable",
            onClick: () => selected.set(target),
            onMouseEnter: () => focused.set(target),
            onMouseLeave: () => focused.set(void 0)
          } : selectedElement ? { class: "selected", onClick: () => selected.set(void 0) } : {}, asButton = selectable || selectedElement;
          return createElement("li", props, [
            createElement(asButton ? "button" : "div", asButton ? { type: "button" } : {}, [
              selectedElement ? createIcon("chevronLeft") : null,
              createElement("code", {}, [target.element.outerHTML]),
              selectable ? createIcon("chevronRight") : null
            ])
          ]);
        })
      )
    )), selected.get() || targets.get().length === 1) {
      let target = selected.get() || targets.get()[0], menuGroups = target.menu?.filter(
        (group) => group.some(
          (item) => !item.selectors || item.selectors.some((s) => target.selectors.includes(s))
        )
      );
      menuGroups?.length && menu.appendChild(
        createElement(
          "ul",
          { class: "menu-list" },
          menuGroups.map(
            (menuItems) => createElement("li", {}, [
              createElement(
                "ul",
                { class: "menu-items" },
                menuItems.map(
                  ({ id, title, description, iconLeft, iconRight, clickEvent: event }) => {
                    let onClick = event && (() => channel.emit(event, id, getEventDetails(target)));
                    return createElement("li", {}, [
                      createElement(
                        onClick ? "button" : "div",
                        onClick ? { class: "menu-item", type: "button", onClick } : { class: "menu-item" },
                        [
                          iconLeft ? createIcon(iconLeft) : null,
                          createElement("div", { class: "menu-item-content" }, [
                            createElement(description ? "strong" : "span", {}, [title]),
                            description && createElement("span", {}, [description])
                          ]),
                          iconRight ? createIcon(iconRight) : null
                        ]
                      )
                    ]);
                  }
                )
              )
            ])
          )
        )
      );
    }
    let coords = clickCoords.get();
    coords ? (Object.assign(menu.style, {
      display: "block",
      left: `${menu.style.position === "fixed" ? coords.x - window.scrollX : coords.x}px`,
      top: `${menu.style.position === "fixed" ? coords.y - window.scrollY : coords.y}px`
    }), showPopover(menu), requestAnimationFrame(() => keepInViewport(menu, coords, { topOffset: 15, centered: true }))) : (hidePopover(menu), Object.assign(menu.style, { display: "none" }));
  };
  targets.subscribe(renderMenu), selected.subscribe(renderMenu);
  let addHighlight = (highlight) => {
    let info = normalizeOptions(highlight);
    highlights.set((value) => {
      let others = info.id ? value.filter((h) => h.id !== info.id) : value;
      return info.selectors?.length ? [...others, info] : others;
    });
  }, removeHighlight = (id) => {
    id && highlights.set((value) => value.filter((h) => h.id !== id));
  }, resetState = () => {
    highlights.set([]), elements.set(/* @__PURE__ */ new Map()), boxes.set([]), clickCoords.set(void 0), hoverCoords.set(void 0), targets.set([]), hovered.set([]), focused.set(void 0), selected.set(void 0);
  }, removeTimeout, scrollIntoView = (target, options) => {
    let id = "scrollIntoView-highlight";
    clearTimeout(removeTimeout), removeHighlight(id);
    let element = document32.querySelector(target);
    if (!element) {
      console.warn(`Cannot scroll into view: ${target} not found`);
      return;
    }
    element.scrollIntoView({ behavior: "smooth", block: "center", ...options });
    let keyframeName = `kf-${Math.random().toString(36).substring(2, 15)}`;
    highlights.set((value) => [
      ...value,
      {
        id,
        priority: 1e3,
        selectors: [target],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${keyframeName} 3s linear forwards`
        },
        keyframes: `@keyframes ${keyframeName} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]), removeTimeout = setTimeout(() => removeHighlight(id), 3500);
  }, onMouseMove = (event) => {
    requestAnimationFrame(() => hoverCoords.set({ x: event.pageX, y: event.pageY }));
  };
  document32.body.addEventListener("mousemove", onMouseMove), channel.on(HIGHLIGHT, addHighlight), channel.on(REMOVE_HIGHLIGHT, removeHighlight), channel.on(RESET_HIGHLIGHT, resetState), channel.on(SCROLL_INTO_VIEW, scrollIntoView), channel.on(STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {
    newPhase === "loading" && resetState();
  });
};
globalThis?.FEATURES?.highlight && addons?.ready && addons.ready().then(useHighlights);
var preview_default4 = () => definePreviewAddon9({});
function getDocumentWidthAndHeight() {
  let container = scope.document.documentElement, height = Math.max(container.scrollHeight, container.offsetHeight);
  return { width: Math.max(container.scrollWidth, container.offsetWidth), height };
}
function createCanvas() {
  let canvas = scope.document.createElement("canvas");
  canvas.id = "storybook-addon-measure";
  let context = canvas.getContext("2d");
  invariant(context != null);
  let { width, height } = getDocumentWidthAndHeight();
  return setCanvasWidthAndHeight(canvas, context, { width, height }), canvas.style.position = "absolute", canvas.style.left = "0", canvas.style.top = "0", canvas.style.zIndex = "2147483647", canvas.style.pointerEvents = "none", scope.document.body.appendChild(canvas), { canvas, context, width, height };
}
function setCanvasWidthAndHeight(canvas, context, { width, height }) {
  canvas.style.width = `${width}px`, canvas.style.height = `${height}px`;
  let scale = scope.window.devicePixelRatio;
  canvas.width = Math.floor(width * scale), canvas.height = Math.floor(height * scale), context.scale(scale, scale);
}
var state2 = {};
function init() {
  state2.canvas || (state2 = createCanvas());
}
function clear() {
  state2.context && state2.context.clearRect(0, 0, state2.width ?? 0, state2.height ?? 0);
}
function draw(callback) {
  clear(), callback(state2.context);
}
function rescale() {
  invariant(state2.canvas, "Canvas should exist in the state."), invariant(state2.context, "Context should exist in the state."), setCanvasWidthAndHeight(state2.canvas, state2.context, { width: 0, height: 0 });
  let { width, height } = getDocumentWidthAndHeight();
  setCanvasWidthAndHeight(state2.canvas, state2.context, { width, height }), state2.width = width, state2.height = height;
}
function destroy() {
  state2.canvas && (clear(), state2.canvas.parentNode?.removeChild(state2.canvas), state2 = {});
}
var colors = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
};
var labelPadding = 6;
function roundedRect(context, { x, y, w, h, r }) {
  x = x - w / 2, y = y - h / 2, w < 2 * r && (r = w / 2), h < 2 * r && (r = h / 2), context.beginPath(), context.moveTo(x + r, y), context.arcTo(x + w, y, x + w, y + h, r), context.arcTo(x + w, y + h, x, y + h, r), context.arcTo(x, y + h, x, y, r), context.arcTo(x, y, x + w, y, r), context.closePath();
}
function positionCoordinate(position, { padding, border, width, height, top, left }) {
  let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom, x = left + border.left + padding.left, y = top + border.top + padding.top;
  return position === "top" ? x += contentWidth / 2 : position === "right" ? (x += contentWidth, y += contentHeight / 2) : position === "bottom" ? (x += contentWidth / 2, y += contentHeight) : position === "left" ? y += contentHeight / 2 : position === "center" && (x += contentWidth / 2, y += contentHeight / 2), { x, y };
}
function offset(type, position, { margin, border, padding }, labelPaddingSize, external) {
  let shift = (dir) => 0, offsetX = 0, offsetY = 0, locationMultiplier = external ? 1 : 0.5, labelPaddingShift = external ? labelPaddingSize * 2 : 0;
  return type === "padding" ? shift = (dir) => padding[dir] * locationMultiplier + labelPaddingShift : type === "border" ? shift = (dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift : type === "margin" && (shift = (dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift), position === "top" ? offsetY = -shift("top") : position === "right" ? offsetX = shift("right") : position === "bottom" ? offsetY = shift("bottom") : position === "left" && (offsetX = -shift("left")), { offsetX, offsetY };
}
function collide(a, b) {
  return Math.abs(a.x - b.x) < Math.abs(a.w + b.w) / 2 && Math.abs(a.y - b.y) < Math.abs(a.h + b.h) / 2;
}
function overlapAdjustment(position, currentRect, prevRect) {
  return position === "top" ? currentRect.y = prevRect.y - prevRect.h - labelPadding : position === "right" ? currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2 : position === "bottom" ? currentRect.y = prevRect.y + prevRect.h + labelPadding : position === "left" && (currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2), { x: currentRect.x, y: currentRect.y };
}
function textWithRect(context, type, { x, y, w, h }, text) {
  return roundedRect(context, { x, y, w, h, r: 3 }), context.fillStyle = `${colors[type]}dd`, context.fill(), context.strokeStyle = colors[type], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x, y), roundedRect(context, { x, y, w, h, r: 3 }), context.fillStyle = `${colors[type]}dd`, context.fill(), context.strokeStyle = colors[type], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x, y), { x, y, w, h };
}
function configureText(context, text) {
  context.font = "600 12px monospace", context.textBaseline = "middle", context.textAlign = "center";
  let metrics = context.measureText(text), actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent, w = metrics.width + labelPadding * 2, h = actualHeight + labelPadding * 2;
  return { w, h };
}
function drawLabel(context, measurements, { type, position = "center", text }, prevRect, external = false) {
  let { x, y } = positionCoordinate(position, measurements), { offsetX, offsetY } = offset(type, position, measurements, labelPadding + 1, external);
  x += offsetX, y += offsetY;
  let { w, h } = configureText(context, text);
  if (prevRect && collide({ x, y, w, h }, prevRect)) {
    let adjusted = overlapAdjustment(position, { x, y, w, h }, prevRect);
    x = adjusted.x, y = adjusted.y;
  }
  return textWithRect(context, type, { x, y, w, h }, text);
}
function floatingOffset(alignment, { w, h }) {
  let deltaW = w * 0.5 + labelPadding, deltaH = h * 0.5 + labelPadding;
  return {
    offsetX: (alignment.x === "left" ? -1 : 1) * deltaW,
    offsetY: (alignment.y === "top" ? -1 : 1) * deltaH
  };
}
function drawFloatingLabel(context, measurements, { type, text }) {
  let { floatingAlignment: floatingAlignment2, extremities } = measurements, x = extremities[floatingAlignment2.x], y = extremities[floatingAlignment2.y], { w, h } = configureText(context, text), { offsetX, offsetY } = floatingOffset(floatingAlignment2, {
    w,
    h
  });
  return x += offsetX, y += offsetY, textWithRect(context, type, { x, y, w, h }, text);
}
function drawStack(context, measurements, stack, external) {
  let rects = [];
  stack.forEach((l, idx) => {
    let rect = external && l.position === "center" ? drawFloatingLabel(context, measurements, l) : drawLabel(context, measurements, l, rects[idx - 1], external);
    rects[idx] = rect;
  });
}
function labelStacks(context, measurements, labels, externalLabels) {
  let stacks = labels.reduce((acc, l) => (Object.prototype.hasOwnProperty.call(acc, l.position) || (acc[l.position] = []), acc[l.position]?.push(l), acc), {});
  stacks.top && drawStack(context, measurements, stacks.top, externalLabels), stacks.right && drawStack(context, measurements, stacks.right, externalLabels), stacks.bottom && drawStack(context, measurements, stacks.bottom, externalLabels), stacks.left && drawStack(context, measurements, stacks.left, externalLabels), stacks.center && drawStack(context, measurements, stacks.center, externalLabels);
}
var colors2 = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
};
var SMALL_NODE_SIZE = 30;
function pxToNumber(px) {
  return parseInt(px.replace("px", ""), 10);
}
function round(value) {
  return Number.isInteger(value) ? value : value.toFixed(2);
}
function filterZeroValues(labels) {
  return labels.filter((l) => l.text !== 0 && l.text !== "0");
}
function floatingAlignment(extremities) {
  let windowExtremities = {
    top: scope.window.scrollY,
    bottom: scope.window.scrollY + scope.window.innerHeight,
    left: scope.window.scrollX,
    right: scope.window.scrollX + scope.window.innerWidth
  }, distances = {
    top: Math.abs(windowExtremities.top - extremities.top),
    bottom: Math.abs(windowExtremities.bottom - extremities.bottom),
    left: Math.abs(windowExtremities.left - extremities.left),
    right: Math.abs(windowExtremities.right - extremities.right)
  };
  return {
    x: distances.left > distances.right ? "left" : "right",
    y: distances.top > distances.bottom ? "top" : "bottom"
  };
}
function measureElement(element) {
  let style = scope.getComputedStyle(element), { top, left, right, bottom, width, height } = element.getBoundingClientRect(), {
    marginTop,
    marginBottom,
    marginLeft,
    marginRight,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight,
    borderBottomWidth,
    borderTopWidth,
    borderLeftWidth,
    borderRightWidth
  } = style;
  top = top + scope.window.scrollY, left = left + scope.window.scrollX, bottom = bottom + scope.window.scrollY, right = right + scope.window.scrollX;
  let margin = {
    top: pxToNumber(marginTop),
    bottom: pxToNumber(marginBottom),
    left: pxToNumber(marginLeft),
    right: pxToNumber(marginRight)
  }, padding = {
    top: pxToNumber(paddingTop),
    bottom: pxToNumber(paddingBottom),
    left: pxToNumber(paddingLeft),
    right: pxToNumber(paddingRight)
  }, border = {
    top: pxToNumber(borderTopWidth),
    bottom: pxToNumber(borderBottomWidth),
    left: pxToNumber(borderLeftWidth),
    right: pxToNumber(borderRightWidth)
  }, extremities = {
    top: top - margin.top,
    bottom: bottom + margin.bottom,
    left: left - margin.left,
    right: right + margin.right
  };
  return {
    margin,
    padding,
    border,
    top,
    left,
    bottom,
    right,
    width,
    height,
    extremities,
    floatingAlignment: floatingAlignment(extremities)
  };
}
function drawMargin(context, { margin, width, height, top, left, bottom, right }) {
  let marginHeight = height + margin.bottom + margin.top;
  context.fillStyle = colors2.margin, context.fillRect(left, top - margin.top, width, margin.top), context.fillRect(right, top - margin.top, margin.right, marginHeight), context.fillRect(left, bottom, width, margin.bottom), context.fillRect(left - margin.left, top - margin.top, margin.left, marginHeight);
  let marginLabels = [
    {
      type: "margin",
      text: round(margin.top),
      position: "top"
    },
    {
      type: "margin",
      text: round(margin.right),
      position: "right"
    },
    {
      type: "margin",
      text: round(margin.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: round(margin.left),
      position: "left"
    }
  ];
  return filterZeroValues(marginLabels);
}
function drawPadding(context, { padding, border, width, height, top, left, bottom, right }) {
  let paddingWidth = width - border.left - border.right, paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  context.fillStyle = colors2.padding, context.fillRect(left + border.left, top + border.top, paddingWidth, padding.top), context.fillRect(
    right - padding.right - border.right,
    top + padding.top + border.top,
    padding.right,
    paddingHeight
  ), context.fillRect(
    left + border.left,
    bottom - padding.bottom - border.bottom,
    paddingWidth,
    padding.bottom
  ), context.fillRect(left + border.left, top + padding.top + border.top, padding.left, paddingHeight);
  let paddingLabels = [
    {
      type: "padding",
      text: padding.top,
      position: "top"
    },
    {
      type: "padding",
      text: padding.right,
      position: "right"
    },
    {
      type: "padding",
      text: padding.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: padding.left,
      position: "left"
    }
  ];
  return filterZeroValues(paddingLabels);
}
function drawBorder(context, { border, width, height, top, left, bottom, right }) {
  let borderHeight = height - border.top - border.bottom;
  context.fillStyle = colors2.border, context.fillRect(left, top, width, border.top), context.fillRect(left, bottom - border.bottom, width, border.bottom), context.fillRect(left, top + border.top, border.left, borderHeight), context.fillRect(right - border.right, top + border.top, border.right, borderHeight);
  let borderLabels = [
    {
      type: "border",
      text: border.top,
      position: "top"
    },
    {
      type: "border",
      text: border.right,
      position: "right"
    },
    {
      type: "border",
      text: border.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: border.left,
      position: "left"
    }
  ];
  return filterZeroValues(borderLabels);
}
function drawContent(context, { padding, border, width, height, top, left }) {
  let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  return context.fillStyle = colors2.content, context.fillRect(
    left + border.left + padding.left,
    top + border.top + padding.top,
    contentWidth,
    contentHeight
  ), [
    {
      type: "content",
      position: "center",
      text: `${round(contentWidth)} x ${round(contentHeight)}`
    }
  ];
}
function drawBoxModel(element) {
  return (context) => {
    if (element && context) {
      let measurements = measureElement(element), marginLabels = drawMargin(context, measurements), paddingLabels = drawPadding(context, measurements), borderLabels = drawBorder(context, measurements), contentLabels = drawContent(context, measurements), externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;
      labelStacks(
        context,
        measurements,
        [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],
        externalLabels
      );
    }
  };
}
function drawSelectedElement(element) {
  draw(drawBoxModel(element));
}
var deepElementFromPoint = (x, y) => {
  let element = scope.document.elementFromPoint(x, y), crawlShadows = (node) => {
    if (node && node.shadowRoot) {
      let nestedElement = node.shadowRoot.elementFromPoint(x, y);
      return node.isEqualNode(nestedElement) ? node : nestedElement.shadowRoot ? crawlShadows(nestedElement) : nestedElement;
    }
    return node;
  };
  return crawlShadows(element) || element;
};
var nodeAtPointerRef;
var pointer = { x: 0, y: 0 };
function findAndDrawElement(x, y) {
  nodeAtPointerRef = deepElementFromPoint(x, y), drawSelectedElement(nodeAtPointerRef);
}
var withMeasure = (StoryFn, context) => {
  let { measureEnabled } = context.globals || {};
  return useEffect(() => {
    if (typeof globalThis.document > "u")
      return;
    let onPointerMove = (event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation(), pointer.x = event.clientX, pointer.y = event.clientY;
      });
    };
    return globalThis.document.addEventListener("pointermove", onPointerMove), () => {
      globalThis.document.removeEventListener("pointermove", onPointerMove);
    };
  }, []), useEffect(() => {
    let onPointerOver = (event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation(), findAndDrawElement(event.clientX, event.clientY);
      });
    }, onResize = () => {
      window.requestAnimationFrame(() => {
        rescale();
      });
    };
    return context.viewMode === "story" && measureEnabled && (globalThis.document.addEventListener("pointerover", onPointerOver), init(), globalThis.window.addEventListener("resize", onResize), findAndDrawElement(pointer.x, pointer.y)), () => {
      globalThis.window.removeEventListener("resize", onResize), destroy();
    };
  }, [measureEnabled, context.viewMode]), StoryFn();
};
var decorators2 = globalThis.FEATURES?.measure ? [withMeasure] : [];
var initialGlobals2 = {
  [PARAM_KEY2]: false
};
var preview_default5 = () => definePreviewAddon9({
  decorators: decorators2,
  initialGlobals: initialGlobals2
});
var clearStyles2 = (selector) => {
  (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle2);
};
var clearStyle2 = (input) => {
  let selector = typeof input == "string" ? input : input.join(""), element = scope.document.getElementById(selector);
  element && element.parentElement && element.parentElement.removeChild(element);
};
var addOutlineStyles = (selector, css) => {
  let existingStyle = scope.document.getElementById(selector);
  if (existingStyle)
    existingStyle.innerHTML !== css && (existingStyle.innerHTML = css);
  else {
    let style = scope.document.createElement("style");
    style.setAttribute("id", selector), style.innerHTML = css, scope.document.head.appendChild(style);
  }
};
function outlineCSS(selector) {
  return dedent`
    ${selector} body {
      outline: 1px solid #2980b9 !important;
    }

    ${selector} article {
      outline: 1px solid #3498db !important;
    }

    ${selector} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${selector} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${selector} section {
      outline: 1px solid #66b8da !important;
    }

    ${selector} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${selector} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${selector} h1 {
      outline: 1px solid #162544 !important;
    }

    ${selector} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${selector} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${selector} h4 {
      outline: 1px solid #449baf !important;
    }

    ${selector} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${selector} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${selector} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${selector} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${selector} div {
      outline: 1px solid #036cdb !important;
    }

    ${selector} p {
      outline: 1px solid #ac050b !important;
    }

    ${selector} hr {
      outline: 1px solid #ff063f !important;
    }

    ${selector} pre {
      outline: 1px solid #850440 !important;
    }

    ${selector} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${selector} ol {
      outline: 1px solid #ff050c !important;
    }

    ${selector} ul {
      outline: 1px solid #d90416 !important;
    }

    ${selector} li {
      outline: 1px solid #d90416 !important;
    }

    ${selector} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${selector} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${selector} dd {
      outline: 1px solid #e80174 !important;
    }

    ${selector} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${selector} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${selector} table {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} thead {
      outline: 1px solid #98daca !important;
    }

    ${selector} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${selector} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${selector} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${selector} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${selector} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${selector} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${selector} button {
      outline: 1px solid #da8301 !important;
    }

    ${selector} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${selector} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${selector} form {
      outline: 1px solid #d23600 !important;
    }

    ${selector} input {
      outline: 1px solid #fca600 !important;
    }

    ${selector} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${selector} label {
      outline: 1px solid #ee8900 !important;
    }

    ${selector} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${selector} meter {
      outline: 1px solid #e8630c !important;
    }

    ${selector} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${selector} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${selector} output {
      outline: 1px solid #ff9619 !important;
    }

    ${selector} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${selector} select {
      outline: 1px solid #e26e0f !important;
    }

    ${selector} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${selector} details {
      outline: 1px solid #33848f !important;
    }

    ${selector} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${selector} command {
      outline: 1px solid #438da1 !important;
    }

    ${selector} menu {
      outline: 1px solid #449da6 !important;
    }

    ${selector} del {
      outline: 1px solid #bf0000 !important;
    }

    ${selector} ins {
      outline: 1px solid #400000 !important;
    }

    ${selector} img {
      outline: 1px solid #22746b !important;
    }

    ${selector} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} embed {
      outline: 1px solid #98daca !important;
    }

    ${selector} object {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} video {
      outline: 1px solid #6ee866 !important;
    }

    ${selector} audio {
      outline: 1px solid #027353 !important;
    }

    ${selector} source {
      outline: 1px solid #012426 !important;
    }

    ${selector} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${selector} track {
      outline: 1px solid #59a600 !important;
    }

    ${selector} map {
      outline: 1px solid #7be500 !important;
    }

    ${selector} area {
      outline: 1px solid #305900 !important;
    }

    ${selector} a {
      outline: 1px solid #ff62ab !important;
    }

    ${selector} em {
      outline: 1px solid #800b41 !important;
    }

    ${selector} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${selector} i {
      outline: 1px solid #803156 !important;
    }

    ${selector} b {
      outline: 1px solid #cc1169 !important;
    }

    ${selector} u {
      outline: 1px solid #ff0430 !important;
    }

    ${selector} s {
      outline: 1px solid #f805e3 !important;
    }

    ${selector} small {
      outline: 1px solid #d107b2 !important;
    }

    ${selector} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${selector} q {
      outline: 1px solid #240018 !important;
    }

    ${selector} cite {
      outline: 1px solid #64003c !important;
    }

    ${selector} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${selector} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${selector} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${selector} time {
      outline: 1px solid #d6606d !important;
    }

    ${selector} code {
      outline: 1px solid #e04251 !important;
    }

    ${selector} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${selector} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${selector} var {
      outline: 1px solid #d90047 !important;
    }

    ${selector} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${selector} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${selector} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${selector} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${selector} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${selector} rp {
      outline: 1px solid #803e49 !important;
    }

    ${selector} span {
      outline: 1px solid #cc2643 !important;
    }

    ${selector} br {
      outline: 1px solid #db687d !important;
    }

    ${selector} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
var withOutline = (StoryFn, context) => {
  let globals = context.globals || {}, isActive = [true, "true"].includes(globals[PARAM_KEY3]), isInDocs = context.viewMode === "docs", outlineStyles = useMemo(() => outlineCSS(isInDocs ? '[data-story-block="true"]' : ".sb-show-main"), [context]);
  return useEffect(() => {
    let selectorId = isInDocs ? `addon-outline-docs-${context.id}` : "addon-outline";
    return isActive ? addOutlineStyles(selectorId, outlineStyles) : clearStyles2(selectorId), () => {
      clearStyles2(selectorId);
    };
  }, [isActive, outlineStyles, context]), StoryFn();
};
var decorators3 = globalThis.FEATURES?.outline ? [withOutline] : [];
var initialGlobals3 = {
  [PARAM_KEY3]: false
};
var preview_default6 = () => definePreviewAddon9({ decorators: decorators3, initialGlobals: initialGlobals3 });
var resetAllMocksLoader = ({ parameters: parameters2 }) => {
  parameters2?.test?.mockReset === true ? resetAllMocks() : parameters2?.test?.clearMocks === true ? clearAllMocks() : parameters2?.test?.restoreMocks !== false && restoreAllMocks();
};
var traverseArgs = (value, depth = 0, key) => {
  if (depth > 5 || value == null)
    return value;
  if (isMockFunction(value))
    return key && value.mockName(key), value;
  if (typeof value == "function" && "isAction" in value && value.isAction && !("implicit" in value && value.implicit)) {
    let mock = fn2(value);
    return key && mock.mockName(key), mock;
  }
  if (Array.isArray(value)) {
    depth++;
    for (let i = 0; i < value.length; i++)
      Object.getOwnPropertyDescriptor(value, i)?.writable && (value[i] = traverseArgs(value[i], depth));
    return value;
  }
  if (typeof value == "object" && value.constructor === Object) {
    depth++;
    for (let [k, v] of Object.entries(value))
      Object.getOwnPropertyDescriptor(value, k)?.writable && (value[k] = traverseArgs(v, depth, k));
    return value;
  }
  return value;
};
var nameSpiesAndWrapActionsInSpies = ({ initialArgs }) => {
  traverseArgs(initialArgs);
};
var patchedFocus = false;
var enhanceContext = async (context) => {
  globalThis.HTMLElement && context.canvasElement instanceof globalThis.HTMLElement && (context.canvas = within(context.canvasElement));
  let clipboard = globalThis.window?.navigator?.clipboard;
  if (clipboard && (context.userEvent = instrument(
    { userEvent: uninstrumentedUserEvent.setup() },
    {
      intercept: true,
      getKeys: (obj) => Object.keys(obj).filter((key) => key !== "eventWrapper")
    }
  ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
    get: () => clipboard,
    configurable: true
  }), !patchedFocus)) {
    let originalFocus = HTMLElement.prototype.focus, currentFocus = HTMLElement.prototype.focus, focusingElements = /* @__PURE__ */ new Set();
    Object.defineProperties(HTMLElement.prototype, {
      focus: {
        configurable: true,
        set: (newFocus) => {
          currentFocus = newFocus;
        },
        get() {
          return focusingElements.has(this) ? originalFocus : (focusingElements.add(this), setTimeout(() => focusingElements.delete(this), 0), currentFocus);
        }
      }
    }), patchedFocus = true;
  }
};
var preview_default7 = () => definePreviewAddon9({
  loaders: [resetAllMocksLoader, nameSpiesAndWrapActionsInSpies, enhanceContext]
});
var initialGlobals4 = {
  [PARAM_KEY4]: { value: void 0, isRotated: false }
};
var preview_default8 = () => definePreviewAddon9({
  initialGlobals: initialGlobals4
});
function getCoreAnnotations() {
  return [
    // @ts-expect-error CJS fallback
    (preview_default5.default ?? preview_default5)(),
    // @ts-expect-error CJS fallback
    (preview_default2.default ?? preview_default2)(),
    // @ts-expect-error CJS fallback
    (preview_default4.default ?? preview_default4)(),
    // @ts-expect-error CJS fallback
    (preview_default6.default ?? preview_default6)(),
    // @ts-expect-error CJS fallback
    (preview_default8.default ?? preview_default8)(),
    // @ts-expect-error CJS fallback
    (preview_default.default ?? preview_default)(),
    // @ts-expect-error CJS fallback
    (preview_default3.default ?? preview_default3)(),
    // @ts-expect-error CJS fallback
    (preview_default7.default ?? preview_default7)()
  ];
}
function definePreviewAddon9(preview) {
  return preview;
}
function isMeta(input) {
  return input != null && typeof input == "object" && "_tag" in input && input?._tag === "Meta";
}
function isStory(input) {
  return input != null && typeof input == "object" && "_tag" in input && input?._tag === "Story";
}
function getStoryChildren(story) {
  return "__children" in story ? story.__children : [];
}
var sanitize = (string) => string.toLowerCase().replace(/[ â€™â€“â€”â€•â€²Â¿'`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
var sanitizeSafe = (string, part) => {
  let sanitized = sanitize(string);
  if (sanitized === "")
    throw new Error(`Invalid ${part} '${string}', must include alphanumeric characters`);
  return sanitized;
};
var toId = (kind, name) => `${sanitizeSafe(kind, "kind")}${name ? `--${sanitizeSafe(name, "name")}` : ""}`;
var toTestId = (parentId, testName) => `${parentId}:${sanitizeSafe(testName, "test")}`;
var storyNameFromExport = (key) => toStartCaseStr(key);
function matches(storyKey, arrayOrRegex) {
  return Array.isArray(arrayOrRegex) ? arrayOrRegex.includes(storyKey) : storyKey.match(arrayOrRegex);
}
function isExportStory(key, { includeStories, excludeStories }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    key !== "__esModule" && (!includeStories || matches(key, includeStories)) && (!excludeStories || !matches(key, excludeStories))
  );
}
var combineTags2 = (...tags) => {
  let result = tags.reduce((acc, tag) => (tag.startsWith("!") ? acc.delete(tag.slice(1)) : acc.add(tag), acc), /* @__PURE__ */ new Set());
  return Array.from(result);
};

// node_modules/storybook/dist/_browser-chunks/chunk-MDLQUVZN.js
function mockChannel() {
  let transport = {
    setHandler: () => {
    },
    send: () => {
    }
  };
  return new Channel({ transport });
}
var AddonStore = class {
  constructor() {
    this.getChannel = () => {
      if (!this.channel) {
        let channel = mockChannel();
        return this.setChannel(channel), channel;
      }
      return this.channel;
    };
    this.ready = () => this.promise;
    this.hasChannel = () => !!this.channel;
    this.setChannel = (channel) => {
      this.channel = channel, this.resolve();
    };
    this.promise = new Promise((res) => {
      this.resolve = () => res(this.getChannel());
    });
  }
};
var KEY = "__STORYBOOK_ADDONS_PREVIEW";
function getAddonsStore() {
  return scope[KEY] || (scope[KEY] = new AddonStore()), scope[KEY];
}
var addons = getAddonsStore();
var HooksContext = class {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = (storyId) => {
      storyId === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    };
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((effect) => {
      effect.destroy && effect.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let hook = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, hook;
  }
  triggerEffects() {
    this.prevEffects.forEach((effect) => {
      !this.currentEffects.includes(effect) && effect.destroy && effect.destroy();
    }), this.currentEffects.forEach((effect) => {
      this.prevEffects.includes(effect) || (effect.destroy = effect.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), addons.getChannel().on(STORY_RENDERED, this.renderListener);
  }
  removeRenderListeners() {
    addons.getChannel().removeListener(STORY_RENDERED, this.renderListener);
  }
};
function hookify(fn) {
  let hookified = (...args) => {
    let { hooks } = typeof args[0] == "function" ? args[1] : args[0], prevPhase = hooks.currentPhase, prevHooks = hooks.currentHooks, prevNextHookIndex = hooks.nextHookIndex, prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn.name, hooks.prevMountedDecorators.has(fn) ? (hooks.currentPhase = "UPDATE", hooks.currentHooks = hooks.hookListsMap.get(fn) || []) : (hooks.currentPhase = "MOUNT", hooks.currentHooks = [], hooks.hookListsMap.set(fn, hooks.currentHooks), hooks.prevMountedDecorators.add(fn)), hooks.nextHookIndex = 0;
    let prevContext = scope.STORYBOOK_HOOKS_CONTEXT;
    scope.STORYBOOK_HOOKS_CONTEXT = hooks;
    let result = fn(...args);
    if (scope.STORYBOOK_HOOKS_CONTEXT = prevContext, hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return hooks.currentPhase = prevPhase, hooks.currentHooks = prevHooks, hooks.nextHookIndex = prevNextHookIndex, hooks.currentDecoratorName = prevDecoratorName, result;
  };
  return hookified.originalFn = fn, hookified;
}
var numberOfRenders = 0;
var RENDER_LIMIT = 25;
var applyHooks = (applyDecorators) => (storyFn, decorators4) => {
  let decorated = applyDecorators(
    hookify(storyFn),
    decorators4.map((decorator) => hookify(decorator))
  );
  return (context) => {
    let { hooks } = context;
    hooks.prevMountedDecorators ??= /* @__PURE__ */ new Set(), hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators4]), hooks.currentContext = context, hooks.hasUpdates = false;
    let result = decorated(context);
    for (numberOfRenders = 1; hooks.hasUpdates; )
      if (hooks.hasUpdates = false, hooks.currentEffects = [], result = decorated(context), numberOfRenders += 1, numberOfRenders > RENDER_LIMIT)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return hooks.addRenderListeners(), result;
  };
};
var areDepsEqual = (deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i) => dep === nextDeps[i]);
var invalidHooksError = () => new Error("Storybook preview hooks can only be called inside decorators and story functions.");
function getHooksContextOrNull() {
  return scope.STORYBOOK_HOOKS_CONTEXT || null;
}
function getHooksContextOrThrow() {
  let hooks = getHooksContextOrNull();
  if (hooks == null)
    throw invalidHooksError();
  return hooks;
}
function useHook(name, callback, deps) {
  let hooks = getHooksContextOrThrow();
  if (hooks.currentPhase === "MOUNT") {
    deps != null && !Array.isArray(deps) && logger.warn(
      `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`
    );
    let hook = { name, deps };
    return hooks.currentHooks.push(hook), callback(hook), hook;
  }
  if (hooks.currentPhase === "UPDATE") {
    let hook = hooks.getNextHook();
    if (hook == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return hook.name !== name && logger.warn(
      `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), deps != null && hook.deps == null && logger.warn(
      `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), deps != null && hook.deps != null && deps.length !== hook.deps.length && logger.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.
Previous: ${hook.deps}
Incoming: ${deps}`), (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) && (callback(hook), hook.deps = deps), hook;
  }
  throw invalidHooksError();
}
function useMemoLike(name, nextCreate, deps) {
  let { memoizedState } = useHook(
    name,
    (hook) => {
      hook.memoizedState = nextCreate();
    },
    deps
  );
  return memoizedState;
}
function useMemo(nextCreate, deps) {
  return useMemoLike("useMemo", nextCreate, deps);
}
function useEffect(create, deps) {
  let hooks = getHooksContextOrThrow(), effect = useMemoLike("useEffect", () => ({ create }), deps);
  hooks.currentEffects.includes(effect) || hooks.currentEffects.push(effect);
}
var import_memoizerific2 = __toESM(require_memoizerific(), 1);
var INCOMPATIBLE = /* @__PURE__ */ Symbol("incompatible");
var map = (arg, argType) => {
  let type = argType.type;
  if (arg == null || !type || argType.mapping)
    return arg;
  switch (type.name) {
    case "string":
      return String(arg);
    case "enum":
      return arg;
    case "number":
      return Number(arg);
    case "boolean":
      return String(arg) === "true";
    case "array":
      return !type.value || !Array.isArray(arg) ? INCOMPATIBLE : arg.reduce((acc, item, index) => {
        let mapped = map(item, { type: type.value });
        return mapped !== INCOMPATIBLE && (acc[index] = mapped), acc;
      }, new Array(arg.length));
    case "object":
      return typeof arg == "string" || typeof arg == "number" ? arg : !type.value || typeof arg != "object" ? INCOMPATIBLE : Object.entries(arg).reduce((acc, [key, val]) => {
        let mapped = map(val, { type: type.value[key] });
        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
      }, {});
    case "other": {
      let isPrimitiveArg = typeof arg == "string" || typeof arg == "number" || typeof arg == "boolean";
      return type.value === "ReactNode" && isPrimitiveArg ? arg : INCOMPATIBLE;
    }
    default:
      return INCOMPATIBLE;
  }
};
var mapArgsToTypes = (args, argTypes) => Object.entries(args).reduce((acc, [key, value]) => {
  if (!argTypes[key])
    return acc;
  let mapped = map(value, argTypes[key]);
  return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
}, {});
var combineArgs = (value, update) => Array.isArray(value) && Array.isArray(update) ? update.reduce(
  (acc, upd, index) => (acc[index] = combineArgs(value[index], update[index]), acc),
  [...value]
).filter((v) => v !== void 0) : !isPlainObject(value) || !isPlainObject(update) ? update : Object.keys({ ...value, ...update }).reduce((acc, key) => {
  if (key in update) {
    let combined = combineArgs(value[key], update[key]);
    combined !== void 0 && (acc[key] = combined);
  } else
    acc[key] = value[key];
  return acc;
}, {});
var validateOptions = (args, argTypes) => Object.entries(argTypes).reduce((acc, [key, { options }]) => {
  function allowArg() {
    return key in args && (acc[key] = args[key]), acc;
  }
  if (!options)
    return allowArg();
  if (!Array.isArray(options))
    return once.error(dedent`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `), allowArg();
  if (options.some((opt) => opt && ["object", "function"].includes(typeof opt)))
    return once.error(dedent`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `), allowArg();
  let isArray = Array.isArray(args[key]), invalidIndex = isArray && args[key].findIndex((val) => !options.includes(val)), isValidArray = isArray && invalidIndex === -1;
  if (args[key] === void 0 || options.includes(args[key]) || isValidArray)
    return allowArg();
  let field = isArray ? `${key}[${invalidIndex}]` : key, supportedOptions = options.map((opt) => typeof opt == "string" ? `'${opt}'` : String(opt)).join(", ");
  return once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`), acc;
}, {});
var DEEPLY_EQUAL = /* @__PURE__ */ Symbol("Deeply equal");
var deepDiff = (value, update) => {
  if (typeof value != typeof update)
    return update;
  if (isEqual(value, update))
    return DEEPLY_EQUAL;
  if (Array.isArray(value) && Array.isArray(update)) {
    let res = update.reduce((acc, upd, index) => {
      let diff = deepDiff(value[index], upd);
      return diff !== DEEPLY_EQUAL && (acc[index] = diff), acc;
    }, new Array(update.length));
    return update.length >= value.length ? res : res.concat(new Array(value.length - update.length).fill(void 0));
  }
  return isPlainObject(value) && isPlainObject(update) ? Object.keys({ ...value, ...update }).reduce((acc, key) => {
    let diff = deepDiff(value?.[key], update?.[key]);
    return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff });
  }, {}) : update;
};
var UNTARGETED = "UNTARGETED";
function groupArgsByTarget({
  args,
  argTypes
}) {
  let groupedArgs = {};
  return Object.entries(args).forEach(([name, value]) => {
    let { target = UNTARGETED } = argTypes[name] || {};
    groupedArgs[target] = groupedArgs[target] || {}, groupedArgs[target][name] = value;
  }), groupedArgs;
}
function deleteUndefined(obj) {
  return Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]), obj;
}
var ArgsStore = class {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(storyId) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    return this.argsByStoryId[storyId];
  }
  setInitial(story) {
    if (!this.initialArgsByStoryId[story.id])
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs;
    else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
      let delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs, delta !== DEEPLY_EQUAL && this.updateFromDelta(story, delta);
    }
  }
  updateFromDelta(story, delta) {
    let validatedDelta = validateOptions(delta, story.argTypes);
    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
  }
  updateFromPersisted(story, persisted) {
    let mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
    return this.updateFromDelta(story, mappedPersisted);
  }
  update(storyId, argsUpdate) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    this.argsByStoryId[storyId] = deleteUndefined({
      ...this.argsByStoryId[storyId],
      ...argsUpdate
    });
  }
};
var getValuesFromArgTypes = (argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => (typeof defaultValue < "u" && (acc[arg] = defaultValue), acc), {});
var GlobalsStore = class {
  constructor({
    globals = {},
    globalTypes = {}
  }) {
    this.set({ globals, globalTypes });
  }
  set({ globals = {}, globalTypes = {} }) {
    let delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
    let defaultGlobals = getValuesFromArgTypes(globalTypes);
    this.initialGlobals = { ...defaultGlobals, ...globals }, this.globals = this.initialGlobals, delta && delta !== DEEPLY_EQUAL && this.updateFromPersisted(delta);
  }
  filterAllowedGlobals(globals) {
    return Object.entries(globals).reduce((acc, [key, value]) => (this.allowedGlobalNames.has(key) ? acc[key] = value : logger.warn(
      `Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`
    ), acc), {});
  }
  updateFromPersisted(persisted) {
    let allowedUrlGlobals = this.filterAllowedGlobals(persisted);
    this.globals = { ...this.globals, ...allowedUrlGlobals };
  }
  get() {
    return this.globals;
  }
  update(newGlobals) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };
    for (let key in newGlobals)
      newGlobals[key] === void 0 && (this.globals[key] = this.initialGlobals[key]);
  }
};
var import_memoizerific = __toESM(require_memoizerific(), 1);
var getImportPathMap = (0, import_memoizerific.default)(1)(
  (entries) => Object.values(entries).reduce(
    (acc, entry) => (acc[entry.importPath] = acc[entry.importPath] || entry, acc),
    {}
  )
);
var StoryIndexStore = class {
  constructor({ entries } = { v: 5, entries: {} }) {
    this.entries = entries;
  }
  entryFromSpecifier(specifier) {
    let entries = Object.values(this.entries);
    if (specifier === "*")
      return entries[0];
    if (typeof specifier == "string")
      return this.entries[specifier] ? this.entries[specifier] : entries.find((entry) => entry.id.startsWith(specifier));
    let { name, title } = specifier;
    return entries.find((entry) => entry.name === name && entry.title === title);
  }
  storyIdToEntry(storyId) {
    let storyEntry = this.entries[storyId];
    if (!storyEntry)
      throw new MissingStoryAfterHmrError({ storyId });
    return storyEntry;
  }
  importPathToEntry(importPath) {
    return getImportPathMap(this.entries)[importPath];
  }
};
var normalizeType = (type) => typeof type == "string" ? { name: type } : type;
var normalizeControl = (control) => typeof control == "string" ? { type: control } : control;
var normalizeInputType = (inputType, key) => {
  let { type, control, ...rest } = inputType, normalized = {
    name: key,
    ...rest
  };
  return type && (normalized.type = normalizeType(type)), control ? normalized.control = normalizeControl(control) : control === false && (normalized.control = { disable: true }), normalized;
};
var normalizeInputTypes = (inputTypes) => mapValues(inputTypes, normalizeInputType);
var normalizeArrays = (array) => Array.isArray(array) ? array : array ? [array] : [];
var deprecatedStoryAnnotation = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function normalizeStory(key, storyAnnotations, meta) {
  let storyObject = storyAnnotations, userStoryFn = typeof storyAnnotations == "function" ? storyAnnotations : null, { story } = storyObject;
  story && (logger.debug("deprecated story", story), deprecate(deprecatedStoryAnnotation));
  let exportName = storyNameFromExport(key), name = typeof storyObject != "function" && storyObject.name || storyObject.storyName || story?.name || exportName, decorators4 = [
    ...normalizeArrays(storyObject.decorators),
    ...normalizeArrays(story?.decorators)
  ], parameters2 = { ...story?.parameters, ...storyObject.parameters }, args = { ...story?.args, ...storyObject.args }, argTypes = { ...story?.argTypes, ...storyObject.argTypes }, loaders2 = [...normalizeArrays(storyObject.loaders), ...normalizeArrays(story?.loaders)], beforeEach = [
    ...normalizeArrays(storyObject.beforeEach),
    ...normalizeArrays(story?.beforeEach)
  ], afterEach = [
    ...normalizeArrays(storyObject.afterEach),
    ...normalizeArrays(story?.afterEach)
  ], { render, play, tags = [], globals = {} } = storyObject, id = parameters2.__id || toId(meta.id, exportName);
  return {
    moduleExport: storyAnnotations,
    id,
    name,
    tags,
    decorators: decorators4,
    parameters: parameters2,
    args,
    argTypes: normalizeInputTypes(argTypes),
    loaders: loaders2,
    beforeEach,
    afterEach,
    globals,
    ...render && { render },
    ...userStoryFn && { userStoryFn },
    ...play && { play }
  };
}
function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
  let { id, argTypes } = defaultExport;
  return {
    id: sanitize(id || title),
    ...defaultExport,
    title,
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    parameters: {
      fileName: importPath,
      ...defaultExport.parameters
    }
  };
}
var checkGlobals = (parameters2) => {
  let { globals, globalTypes } = parameters2;
  (globals || globalTypes) && logger.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals,
      globalTypes
    })
  );
};
var checkStorySort = (parameters2) => {
  let { options } = parameters2;
  options?.storySort && logger.error("The storySort option parameter can only be set globally");
};
var checkDisallowedParameters = (parameters2) => {
  parameters2 && (checkGlobals(parameters2), checkStorySort(parameters2));
};
function processCSFFile(moduleExports, importPath, title) {
  let { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports, factoryStory = Object.values(namedExports).find((it) => isStory(it));
  if (factoryStory) {
    let meta2 = normalizeComponentAnnotations(factoryStory.meta.input, title, importPath);
    checkDisallowedParameters(meta2.parameters);
    let csfFile2 = { meta: meta2, stories: {}, moduleExports };
    return Object.keys(namedExports).forEach((key) => {
      if (isExportStory(key, meta2) && isStory(namedExports[key])) {
        let story = namedExports[key], storyMeta = normalizeStory(key, story.input, meta2);
        checkDisallowedParameters(storyMeta.parameters), csfFile2.stories[storyMeta.id] = storyMeta, getStoryChildren(story).forEach((child) => {
          let name = child.input.name, childId = toTestId(storyMeta.id, name);
          child.input.parameters ??= {}, child.input.parameters.__id = childId, csfFile2.stories[childId] = normalizeStory(name, child.input, meta2);
        });
      }
    }), csfFile2.projectAnnotations = factoryStory.meta.preview.composed, csfFile2;
  }
  let meta = normalizeComponentAnnotations(
    defaultExport,
    title,
    importPath
  );
  checkDisallowedParameters(meta.parameters);
  let csfFile = { meta, stories: {}, moduleExports };
  return Object.keys(namedExports).forEach((key) => {
    if (isExportStory(key, meta)) {
      let storyMeta = normalizeStory(key, namedExports[key], meta);
      checkDisallowedParameters(storyMeta.parameters), csfFile.stories[storyMeta.id] = storyMeta;
    }
  }), csfFile;
}
function mountDestructured(playFunction) {
  return playFunction != null && getUsedProps(playFunction).includes("mount");
}
function getUsedProps(fn) {
  let match = fn.toString().match(/[^(]*\(([^)]*)/);
  if (!match)
    return [];
  let args = splitByComma(match[1]);
  if (!args.length)
    return [];
  let first = args[0];
  return first.startsWith("{") && first.endsWith("}") ? splitByComma(first.slice(1, -1).replace(/\s/g, "")).map((prop) => prop.replace(/:.*|=.*/g, "")) : [];
}
function splitByComma(s) {
  let result = [], stack = [], start = 0;
  for (let i = 0; i < s.length; i++)
    if (s[i] === "{" || s[i] === "[")
      stack.push(s[i] === "{" ? "}" : "]");
    else if (s[i] === stack[stack.length - 1])
      stack.pop();
    else if (!stack.length && s[i] === ",") {
      let token = s.substring(start, i).trim();
      token && result.push(token), start = i + 1;
    }
  let lastToken = s.substring(start).trim();
  return lastToken && result.push(lastToken), result;
}
function decorateStory(storyFn, decorator, bindWithContext) {
  let boundStoryFunction = bindWithContext(storyFn);
  return (context) => decorator(boundStoryFunction, context);
}
function sanitizeStoryContextUpdate({
  componentId,
  title,
  kind,
  id,
  name,
  story,
  parameters: parameters2,
  initialArgs,
  argTypes,
  ...update
} = {}) {
  return update;
}
function defaultDecorateStory(storyFn, decorators4) {
  let contextStore = {}, bindWithContext = (decoratedStoryFn) => (update) => {
    if (!contextStore.value)
      throw new Error("Decorated function called without init");
    return contextStore.value = {
      ...contextStore.value,
      ...sanitizeStoryContextUpdate(update)
    }, decoratedStoryFn(contextStore.value);
  }, decoratedWithContextStore = decorators4.reduce(
    (story, decorator) => decorateStory(story, decorator, bindWithContext),
    storyFn
  );
  return (context) => (contextStore.value = context, decoratedWithContextStore(context));
}
function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
  let { moduleExport, id, name } = storyAnnotations || {}, partialAnnotations = preparePartialAnnotations(
    storyAnnotations,
    componentAnnotations,
    projectAnnotations
  ), applyLoaders = async (context) => {
    let loaded = {};
    for (let loaders2 of [
      normalizeArrays(projectAnnotations.loaders),
      normalizeArrays(componentAnnotations.loaders),
      normalizeArrays(storyAnnotations.loaders)
    ]) {
      if (context.abortSignal.aborted)
        return loaded;
      let loadResults = await Promise.all(loaders2.map((loader) => loader(context)));
      Object.assign(loaded, ...loadResults);
    }
    return loaded;
  }, applyBeforeEach = async (context) => {
    let cleanupCallbacks = new Array();
    for (let beforeEach of [
      ...normalizeArrays(projectAnnotations.beforeEach),
      ...normalizeArrays(componentAnnotations.beforeEach),
      ...normalizeArrays(storyAnnotations.beforeEach)
    ]) {
      if (context.abortSignal.aborted)
        return cleanupCallbacks;
      let cleanup = await beforeEach(context);
      cleanup && cleanupCallbacks.push(cleanup);
    }
    return cleanupCallbacks;
  }, applyAfterEach = async (context) => {
    let reversedFinalizers = [
      ...normalizeArrays(projectAnnotations.afterEach),
      ...normalizeArrays(componentAnnotations.afterEach),
      ...normalizeArrays(storyAnnotations.afterEach)
    ].reverse();
    for (let finalizer of reversedFinalizers) {
      if (context.abortSignal.aborted)
        return;
      await finalizer(context);
    }
  }, undecoratedStoryFn = (context) => context.originalStoryFn(context.args, context), { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations, decorators4 = [
    ...normalizeArrays(storyAnnotations?.decorators),
    ...normalizeArrays(componentAnnotations?.decorators),
    ...normalizeArrays(projectAnnotations?.decorators)
  ], render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render, decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators4), unboundStoryFn = (context) => decoratedStoryFn(context), playFunction = storyAnnotations?.play ?? componentAnnotations?.play, usesMount = mountDestructured(playFunction);
  if (!render && !usesMount)
    throw new NoRenderFunctionError({ id });
  let defaultMount = (context) => async () => (await context.renderToCanvas(), context.canvas), mount = storyAnnotations.mount ?? componentAnnotations.mount ?? projectAnnotations.mount ?? defaultMount, testingLibraryRender = projectAnnotations.testingLibraryRender;
  return {
    storyGlobals: {},
    ...partialAnnotations,
    moduleExport,
    id,
    name,
    story: name,
    originalStoryFn: render,
    undecoratedStoryFn,
    unboundStoryFn,
    applyLoaders,
    applyBeforeEach,
    applyAfterEach,
    playFunction,
    runStep,
    mount,
    testingLibraryRender,
    renderToCanvas: projectAnnotations.renderToCanvas,
    usesMount
  };
}
function prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {
  return {
    ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations),
    moduleExport
  };
}
function preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {
  let defaultTags = ["dev", "test"], extraTags = scope.DOCS_OPTIONS?.autodocs === true ? ["autodocs"] : [], overrideTags = storyAnnotations?.tags?.includes("test-fn") ? ["!autodocs"] : [], tags = combineTags2(
    ...defaultTags,
    ...extraTags,
    ...projectAnnotations.tags ?? [],
    ...componentAnnotations.tags ?? [],
    ...overrideTags,
    ...storyAnnotations?.tags ?? []
  ), parameters2 = combineParameters(
    projectAnnotations.parameters,
    componentAnnotations.parameters,
    storyAnnotations?.parameters
  ), { argTypesEnhancers = [], argsEnhancers: argsEnhancers2 = [] } = projectAnnotations, passedArgTypes = combineParameters(
    projectAnnotations.argTypes,
    componentAnnotations.argTypes,
    storyAnnotations?.argTypes
  );
  if (storyAnnotations) {
    let render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;
    parameters2.__isArgsStory = render && render.length > 0;
  }
  let passedArgs = {
    ...projectAnnotations.args,
    ...componentAnnotations.args,
    ...storyAnnotations?.args
  }, storyGlobals = {
    ...componentAnnotations.globals,
    ...storyAnnotations?.globals
  }, contextForEnhancers = {
    componentId: componentAnnotations.id,
    title: componentAnnotations.title,
    kind: componentAnnotations.title,
    // Back compat
    id: storyAnnotations?.id || componentAnnotations.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: storyAnnotations?.name || "__meta",
    story: storyAnnotations?.name || "__meta",
    // Back compat
    component: componentAnnotations.component,
    subcomponents: componentAnnotations.subcomponents,
    tags,
    parameters: parameters2,
    initialArgs: passedArgs,
    argTypes: passedArgTypes,
    storyGlobals
  };
  contextForEnhancers.argTypes = argTypesEnhancers.reduce(
    (accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }),
    contextForEnhancers.argTypes
  );
  let initialArgsBeforeEnhancers = { ...passedArgs };
  contextForEnhancers.initialArgs = [...argsEnhancers2].reduce(
    (accumulatedArgs, enhancer) => ({
      ...accumulatedArgs,
      ...enhancer({
        ...contextForEnhancers,
        initialArgs: accumulatedArgs
      })
    }),
    initialArgsBeforeEnhancers
  );
  let { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;
  return withoutStoryIdentifiers;
}
function prepareContext(context) {
  let { args: unmappedArgs } = context, targetedContext = {
    ...context,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (scope.FEATURES?.argTypeTargetsV7) {
    let argsByTarget = groupArgsByTarget(context);
    targetedContext = {
      ...context,
      allArgs: context.args,
      argsByTarget,
      args: argsByTarget[UNTARGETED] || {}
    };
  }
  let mappedArgs = Object.entries(targetedContext.args).reduce((acc, [key, val]) => {
    if (!targetedContext.argTypes[key]?.mapping)
      return acc[key] = val, acc;
    let mappingFn = (originalValue) => {
      let mapping = targetedContext.argTypes[key].mapping;
      return mapping && originalValue in mapping ? mapping[originalValue] : originalValue;
    };
    return acc[key] = Array.isArray(val) ? val.map(mappingFn) : mappingFn(val), acc;
  }, {}), includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {
    let argType = targetedContext.argTypes[key] || {};
    return includeConditionalArg(argType, mappedArgs, targetedContext.globals) && (acc[key] = val), acc;
  }, {});
  return { ...targetedContext, unmappedArgs, args: includedArgs };
}
var inferType = (value, name, visited) => {
  let type = typeof value;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: type };
    default:
      break;
  }
  return value ? visited.has(value) ? (logger.warn(dedent`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (visited.add(value), Array.isArray(value) ? { name: "array", value: value.length > 0 ? inferType(value[0], name, new Set(visited)) : { name: "other", value: "unknown" } } : { name: "object", value: mapValues(value, (field) => inferType(field, name, new Set(visited))) }) : { name: "object", value: {} };
};
var inferArgTypes = (context) => {
  let { id, argTypes: userArgTypes = {}, initialArgs = {} } = context, argTypes = mapValues(initialArgs, (arg, key) => ({
    name: key,
    type: inferType(arg, `${id}.${key}`, /* @__PURE__ */ new Set())
  })), userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({
    name: key
  }));
  return combineParameters(argTypes, userArgTypesNames, userArgTypes);
};
inferArgTypes.secondPass = true;
var matches2 = (name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor);
var filterArgTypes = (argTypes, include, exclude) => !include && !exclude ? argTypes : argTypes && pickBy(argTypes, (argType, key) => {
  let name = argType.name || key.toString();
  return !!(!include || matches2(name, include)) && (!exclude || !matches2(name, exclude));
});
var inferControl = (argType, name, matchers) => {
  let { type, options } = argType;
  if (type) {
    if (matchers.color && matchers.color.test(name)) {
      let controlType = type.name;
      if (controlType === "string")
        return { control: { type: "color" } };
      controlType !== "enum" && logger.warn(
        `Addon controls: Control of type color only supports string, received "${controlType}" instead`
      );
    }
    if (matchers.date && matchers.date.test(name))
      return { control: { type: "date" } };
    switch (type.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value } = type;
        return { control: { type: value?.length <= 5 ? "radio" : "select" }, options: value };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: options ? "select" : "object" } };
    }
  }
};
var inferControls = (context) => {
  let {
    argTypes,
    parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} }
  } = context;
  if (!__isArgsStory)
    return argTypes;
  let filteredArgTypes = filterArgTypes(argTypes, include, exclude), withControls = mapValues(filteredArgTypes, (argType, name) => argType?.type && inferControl(argType, name.toString(), matchers));
  return combineParameters(withControls, filteredArgTypes);
};
inferControls.secondPass = true;
function normalizeProjectAnnotations({
  argTypes,
  globalTypes,
  argTypesEnhancers,
  decorators: decorators4,
  loaders: loaders2,
  beforeEach,
  afterEach,
  initialGlobals: initialGlobals5,
  ...annotations
}) {
  return {
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) },
    decorators: normalizeArrays(decorators4),
    loaders: normalizeArrays(loaders2),
    beforeEach: normalizeArrays(beforeEach),
    afterEach: normalizeArrays(afterEach),
    argTypesEnhancers: [
      ...argTypesEnhancers || [],
      inferArgTypes,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      inferControls
    ],
    initialGlobals: initialGlobals5,
    ...annotations
  };
}
var composeBeforeAllHooks = (hooks) => async () => {
  let cleanups2 = [];
  for (let hook of hooks) {
    let cleanup = await hook();
    cleanup && cleanups2.unshift(cleanup);
  }
  return async () => {
    for (let cleanup of cleanups2)
      await cleanup();
  };
};
function composeStepRunners(stepRunners) {
  return async (label, play, playContext) => {
    await stepRunners.reduceRight(
      (innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext),
      async () => play(playContext)
    )();
  };
}
function getField(moduleExportList, field) {
  return moduleExportList.map((xs) => xs.default?.[field] ?? xs[field]).filter(Boolean);
}
function getArrayField(moduleExportList, field, options = {}) {
  return getField(moduleExportList, field).reduce((prev, cur) => {
    let normalized = normalizeArrays(cur);
    return options.reverseFileOrder ? [...normalized, ...prev] : [...prev, ...normalized];
  }, []);
}
function getObjectField(moduleExportList, field) {
  return Object.assign({}, ...getField(moduleExportList, field));
}
function getSingletonField(moduleExportList, field) {
  return getField(moduleExportList, field).pop();
}
function composeConfigs(moduleExportList) {
  let allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers"), stepRunners = getField(moduleExportList, "runStep"), beforeAllHooks = getArrayField(moduleExportList, "beforeAll");
  return {
    parameters: combineParameters(...getField(moduleExportList, "parameters")),
    decorators: getArrayField(moduleExportList, "decorators", {
      reverseFileOrder: !(scope.FEATURES?.legacyDecoratorFileOrder ?? false)
    }),
    args: getObjectField(moduleExportList, "args"),
    argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"),
    argTypes: getObjectField(moduleExportList, "argTypes"),
    argTypesEnhancers: [
      ...allArgTypeEnhancers.filter((e) => !e.secondPass),
      ...allArgTypeEnhancers.filter((e) => e.secondPass)
    ],
    initialGlobals: getObjectField(moduleExportList, "initialGlobals"),
    globalTypes: getObjectField(moduleExportList, "globalTypes"),
    loaders: getArrayField(moduleExportList, "loaders"),
    beforeAll: composeBeforeAllHooks(beforeAllHooks),
    beforeEach: getArrayField(moduleExportList, "beforeEach"),
    afterEach: getArrayField(moduleExportList, "afterEach"),
    render: getSingletonField(moduleExportList, "render"),
    renderToCanvas: getSingletonField(moduleExportList, "renderToCanvas"),
    applyDecorators: getSingletonField(moduleExportList, "applyDecorators"),
    runStep: composeStepRunners(stepRunners),
    tags: getArrayField(moduleExportList, "tags"),
    mount: getSingletonField(moduleExportList, "mount"),
    testingLibraryRender: getSingletonField(moduleExportList, "testingLibraryRender")
  };
}
var ReporterAPI = class {
  constructor() {
    this.reports = [];
  }
  async addReport(report) {
    this.reports.push(report);
  }
};
function getCsfFactoryAnnotations(story, meta, projectAnnotations) {
  return isStory(story) ? {
    story: story.input,
    meta: story.meta.input,
    preview: story.meta.preview.composed
  } : { story, meta: isMeta(meta) ? meta.input : meta, preview: projectAnnotations };
}
function setDefaultProjectAnnotations(_defaultProjectAnnotations) {
  globalThis.defaultProjectAnnotations = _defaultProjectAnnotations;
}
var DEFAULT_STORY_TITLE = "ComposedStory";
var DEFAULT_STORY_NAME = "Unnamed Story";
function extractAnnotation(annotation) {
  return annotation ? composeConfigs([annotation]) : {};
}
function setProjectAnnotations(projectAnnotations) {
  let annotations = Array.isArray(projectAnnotations) ? projectAnnotations : [projectAnnotations];
  return globalThis.globalProjectAnnotations = composeConfigs([
    ...getCoreAnnotations(),
    globalThis.defaultProjectAnnotations ?? {},
    composeConfigs(annotations.map(extractAnnotation))
  ]), globalThis.globalProjectAnnotations ?? {};
}
var cleanups = [];
function composeStory(storyAnnotations, componentAnnotations, projectAnnotations, defaultConfig, exportsName) {
  if (storyAnnotations === void 0)
    throw new Error("Expected a story but received undefined.");
  componentAnnotations.title = componentAnnotations.title ?? DEFAULT_STORY_TITLE;
  let normalizedComponentAnnotations = normalizeComponentAnnotations(componentAnnotations), storyName = exportsName || storyAnnotations.storyName || storyAnnotations.story?.name || storyAnnotations.name || DEFAULT_STORY_NAME, normalizedStory = normalizeStory(
    storyName,
    storyAnnotations,
    normalizedComponentAnnotations
  ), normalizedProjectAnnotations = normalizeProjectAnnotations(
    composeConfigs([
      defaultConfig ?? globalThis.globalProjectAnnotations ?? {},
      projectAnnotations ?? {}
    ])
  ), story = prepareStory(
    normalizedStory,
    normalizedComponentAnnotations,
    normalizedProjectAnnotations
  ), globals = {
    ...getValuesFromArgTypes(normalizedProjectAnnotations.globalTypes),
    ...normalizedProjectAnnotations.initialGlobals,
    ...story.storyGlobals
  }, reporting = new ReporterAPI(), initializeContext = () => {
    let context = prepareContext({
      hooks: new HooksContext(),
      globals,
      args: { ...story.initialArgs },
      viewMode: "story",
      reporting,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: (label, play2) => story.runStep(label, play2, context),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: normalizedProjectAnnotations.globalTypes,
      ...story,
      context: null,
      mount: null
    });
    return context.parameters.__isPortableStory = true, context.context = context, story.renderToCanvas && (context.renderToCanvas = async () => {
      let unmount = await story.renderToCanvas?.(
        {
          componentId: story.componentId,
          title: story.title,
          id: story.id,
          name: story.name,
          tags: story.tags,
          showMain: () => {
          },
          showError: (error) => {
            throw new Error(`${error.title}
${error.description}`);
          },
          showException: (error) => {
            throw error;
          },
          forceRemount: true,
          storyContext: context,
          storyFn: () => story.unboundStoryFn(context),
          unboundStoryFn: story.unboundStoryFn
        },
        context.canvasElement
      );
      unmount && cleanups.push(unmount);
    }), context.mount = story.mount(context), context;
  }, loadedContext, play = async (extraContext) => {
    let context = initializeContext();
    return context.canvasElement ??= globalThis?.document?.body, loadedContext && (context.loaded = loadedContext.loaded), Object.assign(context, extraContext), story.playFunction(context);
  }, run = (extraContext) => {
    let context = initializeContext();
    return Object.assign(context, extraContext), runStory(story, context);
  }, playFunction = story.playFunction ? play : void 0;
  return Object.assign(
    function(extraArgs) {
      let context = initializeContext();
      return loadedContext && (context.loaded = loadedContext.loaded), context.args = {
        ...context.initialArgs,
        ...extraArgs
      }, story.unboundStoryFn(context);
    },
    {
      id: story.id,
      storyName,
      load: async () => {
        for (let callback of [...cleanups].reverse())
          await callback();
        cleanups.length = 0;
        let context = initializeContext();
        context.loaded = await story.applyLoaders(context), cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean)), loadedContext = context;
      },
      globals,
      args: story.initialArgs,
      parameters: story.parameters,
      argTypes: story.argTypes,
      play: playFunction,
      run,
      reporting,
      tags: story.tags
    }
  );
}
async function runStory(story, context) {
  for (let callback of [...cleanups].reverse())
    await callback();
  if (cleanups.length = 0, !context.canvasElement) {
    let container = document.createElement("div");
    globalThis?.document?.body?.appendChild(container), context.canvasElement = container, cleanups.push(() => {
      globalThis?.document?.body?.contains(container) && globalThis?.document?.body?.removeChild(container);
    });
  }
  if (context.loaded = await story.applyLoaders(context), context.abortSignal.aborted)
    return;
  cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));
  let playFunction = story.playFunction, isMountDestructured = story.usesMount;
  if (isMountDestructured || await context.mount(), context.abortSignal.aborted)
    return;
  playFunction && (isMountDestructured || (context.mount = async () => {
    throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
  }), await playFunction(context));
  let cleanUp;
  isTestEnvironment() ? cleanUp = pauseAnimations() : await waitForAnimations(context.abortSignal), await story.applyAfterEach(context), await cleanUp?.();
}
var CSF_CACHE_SIZE = 1e3;
var STORY_CACHE_SIZE = 1e4;
var StoryStore = class {
  constructor(storyIndex, importFn, projectAnnotations) {
    this.importFn = importFn;
    this.storyIndex = new StoryIndexStore(storyIndex), this.projectAnnotations = normalizeProjectAnnotations(
      composeConfigs([...getCoreAnnotations(), projectAnnotations])
    );
    let { initialGlobals: initialGlobals5, globalTypes } = this.projectAnnotations;
    this.args = new ArgsStore(), this.userGlobals = new GlobalsStore({ globals: initialGlobals5, globalTypes }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(processCSFFile), this.prepareMetaWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(prepareMeta), this.prepareStoryWithCache = (0, import_memoizerific2.default)(STORY_CACHE_SIZE)(prepareStory);
  }
  setProjectAnnotations(projectAnnotations) {
    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
    let { initialGlobals: initialGlobals5, globalTypes } = projectAnnotations;
    this.userGlobals.set({ globals: initialGlobals5, globalTypes });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    importFn && (this.importFn = importFn), storyIndex && (this.storyIndex.entries = storyIndex.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(storyId) {
    return this.storyIndex.storyIdToEntry(storyId);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(storyId) {
    let { importPath, title } = this.storyIndex.storyIdToEntry(storyId), moduleExports = await this.importFn(importPath);
    return this.processCSFFileWithCache(moduleExports, importPath, title);
  }
  async loadAllCSFFiles() {
    let importPaths = {};
    return Object.entries(this.storyIndex.entries).forEach(([storyId, { importPath }]) => {
      importPaths[importPath] = storyId;
    }), (await Promise.all(
      Object.entries(importPaths).map(async ([importPath, storyId]) => ({
        importPath,
        csfFile: await this.loadCSFFileByStoryId(storyId)
      }))
    )).reduce(
      (acc, { importPath, csfFile }) => (acc[importPath] = csfFile, acc),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile }) {
    let componentAnnotations = csfFile.meta;
    return this.prepareMetaWithCache(
      componentAnnotations,
      this.projectAnnotations,
      csfFile.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId }) {
    let csfFile = await this.loadCSFFileByStoryId(storyId);
    return this.storyFromCSFFile({ storyId, csfFile });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId,
    csfFile
  }) {
    let storyAnnotations = csfFile.stories[storyId];
    if (!storyAnnotations)
      throw new MissingStoryFromCsfFileError({ storyId });
    let componentAnnotations = csfFile.meta, story = this.prepareStoryWithCache(
      storyAnnotations,
      componentAnnotations,
      csfFile.projectAnnotations ?? this.projectAnnotations
    );
    return this.args.setInitial(story), this.hooks[story.id] = this.hooks[story.id] || new HooksContext(), story;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile
  }) {
    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
  }
  async loadEntry(id) {
    let entry = await this.storyIdToEntry(id), storyImports = entry.type === "docs" ? entry.storiesImports : [], [entryExports, ...csfFiles] = await Promise.all([
      this.importFn(entry.importPath),
      ...storyImports.map((storyImportPath) => {
        let firstStoryEntry = this.storyIndex.importPathToEntry(storyImportPath);
        return this.loadCSFFileByStoryId(firstStoryEntry.id);
      })
    ]);
    return { entryExports, csfFiles };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separately to the (immutable) story.
  getStoryContext(story, { forceInitialArgs = false } = {}) {
    let userGlobals = this.userGlobals.get(), { initialGlobals: initialGlobals5 } = this.userGlobals, reporting = new ReporterAPI();
    return prepareContext({
      ...story,
      args: forceInitialArgs ? story.initialArgs : this.args.get(story.id),
      initialGlobals: initialGlobals5,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals,
      reporting,
      globals: {
        ...userGlobals,
        ...story.storyGlobals
      },
      hooks: this.hooks[story.id]
    });
  }
  addCleanupCallbacks(story, ...callbacks) {
    this.cleanupCallbacks[story.id] = (this.cleanupCallbacks[story.id] || []).concat(callbacks);
  }
  async cleanupStory(story) {
    this.hooks[story.id].clean();
    let callbacks = this.cleanupCallbacks[story.id];
    if (callbacks)
      for (let callback of [...callbacks].reverse())
        await callback();
    delete this.cleanupCallbacks[story.id];
  }
  extract(options = { includeDocsOnly: false }) {
    let { cachedCSFFiles } = this;
    if (console.log("extract: extracting stories", cachedCSFFiles), !cachedCSFFiles)
      throw new CalledExtractOnStoreError();
    let stories = Object.entries(this.storyIndex.entries).reduce(
      (acc, [storyId, entry]) => {
        if (entry.type === "docs")
          return acc;
        let csfFile = cachedCSFFiles[entry.importPath], story = this.storyFromCSFFile({ storyId, csfFile });
        return !options.includeDocsOnly && story.parameters.docsOnly || (acc[storyId] = Object.entries(story).reduce(
          (storyAcc, [key, value]) => key === "story" && entry.subtype === "test" ? { ...storyAcc, story: entry.parentName } : key === "moduleExport" || typeof value == "function" ? storyAcc : Array.isArray(value) ? Object.assign(storyAcc, { [key]: value.slice().sort() }) : Object.assign(storyAcc, { [key]: value }),
          {
            args: story.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...story.storyGlobals
            },
            storyId: entry.parent ? entry.parent : storyId
          }
        )), acc;
      },
      {}
    );
    return console.log("extract: stories", stories), stories;
  }
};
var PREPARE_ABORTED = new Error("prepareAborted");
var { AbortController: AbortController2 } = globalThis;
function serializeError(error) {
  try {
    let { name = "Error", message = String(error), stack } = error;
    return { name, message, stack };
  } catch {
    return { name: "Error", message: String(error) };
  }
}
var StoryRender = class {
  constructor(channel, store, renderToScreen, callbacks, id, viewMode, renderOptions = { autoplay: true, forceInitialArgs: false }, story) {
    this.channel = channel;
    this.store = store;
    this.renderToScreen = renderToScreen;
    this.callbacks = callbacks;
    this.id = id;
    this.viewMode = viewMode;
    this.renderOptions = renderOptions;
    this.type = "story";
    this.notYetRendered = true;
    this.rerenderEnqueued = false;
    this.disableKeyListeners = false;
    this.teardownRender = () => {
    };
    this.torndown = false;
    this.abortController = new AbortController2(), this.renderId = Date.now(), story && (this.story = story, this.phase = "preparing");
  }
  async runPhase(signal, phase, phaseFn) {
    this.phase = phase, this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    }), phaseFn && (await phaseFn(), this.checkIfAborted(signal));
  }
  checkIfAborted(signal) {
    return signal.aborted && !["finished", "aborted", "errored"].includes(this.phase) && (this.phase = "aborted", this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    })), signal.aborted;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), PREPARE_ABORTED;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(canvasElement) {
    return this.canvasElement = canvasElement, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    let { forceInitialArgs } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs });
  }
  async render({
    initial = false,
    forceRemount = false
  } = {}) {
    let { canvasElement } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    let story = this.story;
    if (!canvasElement)
      throw new Error("cannot render when canvasElement is unset");
    let {
      id,
      componentId,
      title,
      name,
      tags,
      applyLoaders,
      applyBeforeEach,
      applyAfterEach,
      unboundStoryFn,
      playFunction,
      runStep
    } = story;
    forceRemount && !initial && (this.cancelRender(), this.abortController = new AbortController2());
    let abortSignal = this.abortController.signal, mounted = false, isMountDestructured = story.usesMount;
    try {
      let context = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal,
        canvasElement,
        loaded: {},
        step: (label, play) => runStep(label, play, context),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: async () => {
          let teardown = await this.renderToScreen(renderContext, canvasElement);
          this.teardownRender = teardown || (() => {
          }), mounted = true;
        },
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: async (...args) => {
          this.callbacks.showStoryDuringRender?.();
          let mountReturn = null;
          return await this.runPhase(abortSignal, "rendering", async () => {
            mountReturn = await story.mount(context)(...args);
          }), isMountDestructured && await this.runPhase(abortSignal, "playing"), mountReturn;
        }
      };
      context.context = context;
      let renderContext = {
        componentId,
        title,
        kind: title,
        id,
        name,
        story: name,
        tags,
        ...this.callbacks,
        showError: (error) => (this.phase = "errored", this.callbacks.showError(error)),
        showException: (error) => (this.phase = "errored", this.callbacks.showException(error)),
        forceRemount: forceRemount || this.notYetRendered,
        storyContext: context,
        storyFn: () => unboundStoryFn(context),
        unboundStoryFn
      };
      if (await this.runPhase(abortSignal, "loading", async () => {
        context.loaded = await applyLoaders(context);
      }), abortSignal.aborted)
        return;
      let cleanupCallbacks = await applyBeforeEach(context);
      if (this.store.addCleanupCallbacks(story, ...cleanupCallbacks), this.checkIfAborted(abortSignal) || (!mounted && !isMountDestructured && await context.mount(), this.notYetRendered = false, abortSignal.aborted))
        return;
      let ignoreUnhandledErrors = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === true, unhandledErrors = /* @__PURE__ */ new Set(), onError = (event) => {
        event.error && unhandledErrors.add(event.error);
      }, onUnhandledRejection = (event) => {
        event.reason && unhandledErrors.add(event.reason);
      };
      if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== "errored") {
        window?.addEventListener?.("error", onError), window?.addEventListener?.("unhandledrejection", onUnhandledRejection), this.disableKeyListeners = true;
        try {
          if (isMountDestructured ? await playFunction(context) : (context.mount = async () => {
            throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
          }, await this.runPhase(abortSignal, "playing", async () => playFunction(context))), !mounted)
            throw new NoStoryMountedError();
          this.checkIfAborted(abortSignal), !ignoreUnhandledErrors && unhandledErrors.size > 0 ? await this.runPhase(abortSignal, "errored") : await this.runPhase(abortSignal, "played");
        } catch (error) {
          if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(abortSignal, "errored", async () => {
            this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw error;
          console.error(error);
        }
        if (!ignoreUnhandledErrors && unhandledErrors.size > 0 && this.channel.emit(
          UNHANDLED_ERRORS_WHILE_PLAYING,
          Array.from(unhandledErrors).map(serializeError)
        ), this.disableKeyListeners = false, window?.removeEventListener?.("unhandledrejection", onUnhandledRejection), window?.removeEventListener?.("error", onError), abortSignal.aborted)
          return;
      }
      await this.runPhase(abortSignal, "completing", async () => {
        isTestEnvironment() ? this.store.addCleanupCallbacks(story, pauseAnimations()) : await waitForAnimations(abortSignal);
      }), await this.runPhase(abortSignal, "completed", async () => {
        this.channel.emit(STORY_RENDERED, id);
      }), this.phase !== "errored" && await this.runPhase(abortSignal, "afterEach", async () => {
        await applyAfterEach(context);
      });
      let hasUnhandledErrors = !ignoreUnhandledErrors && unhandledErrors.size > 0, hasSomeReportsFailed = context.reporting.reports.some(
        (report) => report.status === "failed"
      ), hasStoryErrored = hasUnhandledErrors || hasSomeReportsFailed;
      await this.runPhase(
        abortSignal,
        "finished",
        async () => this.channel.emit(STORY_FINISHED, {
          storyId: id,
          status: hasStoryErrored ? "error" : "success",
          reporters: context.reporting.reports
        })
      );
    } catch (err) {
      this.phase = "errored", this.callbacks.showException(err), await this.runPhase(
        abortSignal,
        "finished",
        async () => this.channel.emit(STORY_FINISHED, {
          storyId: id,
          status: "error",
          reporters: []
        })
      );
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = false, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = true;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: true });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === "playing" && (this.abortController.abort(), this.runPhase(this.abortController.signal, "aborted"));
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let i = 0; i < 3; i += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    window?.location?.reload?.(), await new Promise(() => {
    });
  }
};
var { fetch } = scope;
var STORY_INDEX_PATH = "./index.json";
var Preview = class {
  constructor(importFn, getProjectAnnotations, channel = addons.getChannel(), shouldInitialize = true) {
    this.importFn = importFn;
    this.getProjectAnnotations = getProjectAnnotations;
    this.channel = channel;
    this.storyRenders = [];
    this.storeInitializationPromise = new Promise((resolve, reject) => {
      this.resolveStoreInitializationPromise = resolve, this.rejectStoreInitializationPromise = reject;
    }), shouldInitialize && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: (_, method) => {
          if (this.storyStoreValue)
            return deprecate("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[method];
          throw new StoryStoreAccessedBeforeInitializationError();
        }
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      let projectAnnotations = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(projectAnnotations), await this.initializeWithProjectAnnotations(projectAnnotations);
      let userAgent = globalThis?.navigator?.userAgent;
      await this.channel.emit(PREVIEW_INITIALIZED, { userAgent });
    } catch (err) {
      this.rejectStoreInitializationPromise(err);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this)), this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this)), this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this)), this.channel.on(ARGTYPES_INFO_REQUEST, this.onRequestArgTypesInfo.bind(this)), this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this)), this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this)), this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this)), this.channel.on(STORY_HOT_UPDATED, this.onStoryHotUpdated.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      let projectAnnotations = await this.getProjectAnnotations();
      if (this.renderToCanvas = projectAnnotations.renderToCanvas, !this.renderToCanvas)
        throw new MissingRenderToCanvasError();
      return projectAnnotations;
    } catch (err) {
      throw this.renderPreviewEntryError("Error reading preview.js:", err), err;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(projectAnnotations) {
    this.projectAnnotationsBeforeInitialization = projectAnnotations;
    try {
      let storyIndex = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(storyIndex);
    } catch (err) {
      throw this.renderPreviewEntryError("Error loading story index:", err), err;
    }
  }
  async runBeforeAllHook(projectAnnotations) {
    try {
      await this.beforeAllCleanup?.(), this.beforeAllCleanup = await projectAnnotations.beforeAll?.();
    } catch (err) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", err), err;
    }
  }
  async getStoryIndexFromServer() {
    let result = await fetch(STORY_INDEX_PATH);
    if (result.status === 200)
      return result.json();
    throw new StoryIndexFetchError({ text: await result.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(storyIndex) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new StoryStore(
      storyIndex,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "emitGlobals" });
    let payload = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(SET_GLOBALS, payload);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = getProjectAnnotations;
    let projectAnnotations = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(projectAnnotations), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(projectAnnotations);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(projectAnnotations), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        let storyIndex = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(storyIndex);
          return;
        }
        await this.onStoriesChanged({ storyIndex });
      } catch (err) {
        throw this.renderPreviewEntryError("Error loading story index:", err), err;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn, storyIndex });
  }
  async onUpdateGlobals({
    globals: updatedGlobals,
    currentStory
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(updatedGlobals), currentStory) {
      let { initialGlobals: initialGlobals5, storyGlobals, userGlobals, globals } = this.storyStoreValue.getStoryContext(currentStory);
      this.channel.emit(GLOBALS_UPDATED, {
        initialGlobals: initialGlobals5,
        userGlobals,
        storyGlobals,
        globals
      });
    } else {
      let { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
      this.channel.emit(GLOBALS_UPDATED, {
        initialGlobals: initialGlobals5,
        userGlobals: globals,
        storyGlobals: {},
        globals
      });
    }
    await Promise.all(this.storyRenders.map((r) => r.rerender()));
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(storyId, updatedArgs), await Promise.all(
      this.storyRenders.filter((r) => r.id === storyId && !r.renderOptions.forceInitialArgs).map(
        (r) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          r.story && r.story.usesMount ? r.remount() : r.rerender()
        )
      )
    ), this.channel.emit(STORY_ARGS_UPDATED, {
      storyId,
      args: this.storyStoreValue.args.get(storyId)
    });
  }
  async onRequestArgTypesInfo({ id, payload }) {
    try {
      await this.storeInitializationPromise;
      let story = await this.storyStoreValue?.loadStory(payload);
      this.channel.emit(ARGTYPES_INFO_RESPONSE, {
        id,
        success: true,
        payload: { argTypes: story?.argTypes || {} },
        error: null
      });
    } catch (e) {
      this.channel.emit(ARGTYPES_INFO_RESPONSE, {
        id,
        success: false,
        error: e?.message
      });
    }
  }
  async onResetArgs({ storyId, argNames }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onResetArgs" });
    let story = this.storyRenders.find((r) => r.id === storyId)?.story || await this.storyStoreValue.loadStory({ storyId }), updatedArgs = (argNames || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(story.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(storyId))
      ])
    ]).reduce((acc, argName) => (acc[argName] = story.initialArgs[argName], acc), {});
    await this.onUpdateArgs({ storyId, updatedArgs });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((r) => r.rerender()));
  }
  async onForceRemount({ storyId }) {
    await Promise.all(this.storyRenders.filter((r) => r.id === storyId).map((r) => r.remount()));
  }
  async onStoryHotUpdated() {
    await Promise.all(this.storyRenders.map((r) => r.cancelPlayFunction()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(story, element, callbacks, options) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({
        methodName: "renderStoryToElement"
      });
    let render = new StoryRender(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      callbacks,
      story.id,
      "docs",
      options,
      story
    );
    return render.renderToElement(element), this.storyRenders.push(render), async () => {
      await this.teardownRender(render);
    };
  }
  async teardownRender(render, { viewModeChanged } = {}) {
    this.storyRenders = this.storyRenders.filter((r) => r !== render), await render?.teardown?.({ viewModeChanged });
  }
  // API
  async loadStory({ storyId }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId });
  }
  getStoryContext(story, { forceInitialArgs = false } = {}) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(story, { forceInitialArgs });
  }
  async extract(options) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(options);
  }
  // UTILITIES
  renderPreviewEntryError(reason, err) {
    this.previewEntryError = err, logger.error(reason), logger.error(err), this.channel.emit(CONFIG_ERROR, err);
  }
};
var DocsContext = class {
  constructor(channel, store, renderStoryToElement, csfFiles) {
    this.channel = channel;
    this.store = store;
    this.renderStoryToElement = renderStoryToElement;
    this.storyIdByName = (storyName) => {
      let storyId = this.nameToStoryId.get(storyName);
      if (storyId)
        return storyId;
      throw new Error(`No story found with that name: ${storyName}`);
    };
    this.componentStories = () => this.componentStoriesValue;
    this.componentStoriesFromCSFFile = (csfFile) => this.store.componentStoriesFromCSFFile({ csfFile });
    this.storyById = (storyId) => {
      if (!storyId) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      let csfFile = this.storyIdToCSFFile.get(storyId);
      if (!csfFile)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${storyId}`);
      return this.store.storyFromCSFFile({ storyId, csfFile });
    };
    this.getStoryContext = (story) => ({
      ...this.store.getStoryContext(story),
      loaded: {},
      viewMode: "docs"
    });
    this.loadStory = (id) => this.store.loadStory({ storyId: id });
    this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), csfFiles.forEach((csfFile, index) => {
      this.referenceCSFFile(csfFile);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(csfFile) {
    this.exportsToCSFFile.set(csfFile.moduleExports, csfFile), this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      let annotation = csfFile.stories[story.id];
      this.storyIdToCSFFile.set(annotation.id, csfFile), this.exportToStory.set(annotation.moduleExport, story);
    });
  }
  attachCSFFile(csfFile) {
    if (!this.exportsToCSFFile.has(csfFile.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    if (this.attachedCSFFiles.has(csfFile))
      return;
    this.attachedCSFFiles.add(csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      this.nameToStoryId.set(story.name, story.id), this.componentStoriesValue.push(story), this.primaryStory || (this.primaryStory = story);
    });
  }
  referenceMeta(metaExports, attach) {
    let resolved = this.resolveModuleExport(metaExports);
    if (resolved.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    attach && this.attachCSFFile(resolved.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations } = this.store;
    if (!projectAnnotations)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return projectAnnotations;
  }
  resolveAttachedModuleExportType(moduleExportType) {
    if (moduleExportType === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    let firstAttachedCSFFile = Array.from(this.attachedCSFFiles)[0];
    if (moduleExportType === "meta")
      return { type: "meta", csfFile: firstAttachedCSFFile };
    let { component } = firstAttachedCSFFile.meta;
    if (!component)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component };
  }
  resolveModuleExport(moduleExportOrType) {
    let csfFile = this.exportsToCSFFile.get(moduleExportOrType);
    if (!csfFile && moduleExportOrType && typeof moduleExportOrType == "object" && "default" in moduleExportOrType && (csfFile = this.exportsToCSFFile.get(moduleExportOrType.default)), csfFile)
      return { type: "meta", csfFile };
    let story = this.exportToStory.get(
      isStory(moduleExportOrType) ? moduleExportOrType.input : moduleExportOrType
    );
    return story ? { type: "story", story } : { type: "component", component: moduleExportOrType };
  }
  resolveOf(moduleExportOrType, validTypes = []) {
    let resolved;
    if (["component", "meta", "story"].includes(moduleExportOrType)) {
      let type = moduleExportOrType;
      resolved = this.resolveAttachedModuleExportType(type);
    } else
      resolved = this.resolveModuleExport(moduleExportOrType);
    if (validTypes.length && !validTypes.includes(resolved.type)) {
      let prettyType = resolved.type === "component" ? "component or unknown" : resolved.type;
      throw new Error(dedent`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (resolved.type) {
      case "component":
        return {
          ...resolved,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...resolved,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: resolved.csfFile })
        };
      case "story":
      default:
        return resolved;
    }
  }
};
var import_picoquery2 = __toESM(require_main(), 1);
var import_picoquery = __toESM(require_main(), 1);
var { history, document: document22 } = scope;
var import_ansi_to_html = __toESM(require_ansi_to_html(), 1);
var import_picoquery3 = __toESM(require_main(), 1);
var { document: document3 } = scope;
var Mode = ((Mode2) => (Mode2.MAIN = "MAIN", Mode2.NOPREVIEW = "NOPREVIEW", Mode2.PREPARING_STORY = "PREPARING_STORY", Mode2.PREPARING_DOCS = "PREPARING_DOCS", Mode2.ERROR = "ERROR", Mode2))(Mode || {});
var ansiConverter = new import_ansi_to_html.default({
  escapeXML: true
});
var { document: document4 } = scope;
var runScriptTypes = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
];
var SCRIPT = "script";
var SCRIPTS_ROOT_ID = "scripts-root";
function simulateDOMContentLoaded() {
  let DOMContentLoadedEvent = document4.createEvent("Event");
  DOMContentLoadedEvent.initEvent("DOMContentLoaded", true, true), document4.dispatchEvent(DOMContentLoadedEvent);
}
function insertScript($script, callback, $scriptRoot) {
  let scriptEl = document4.createElement("script");
  scriptEl.type = $script.type === "module" ? "module" : "text/javascript", $script.src ? (scriptEl.onload = callback, scriptEl.onerror = callback, scriptEl.src = $script.src) : scriptEl.textContent = $script.innerText, $scriptRoot ? $scriptRoot.appendChild(scriptEl) : document4.head.appendChild(scriptEl), $script.parentNode.removeChild($script), $script.src || callback();
}
function insertScriptsSequentially(scriptsToExecute, callback, index = 0) {
  scriptsToExecute[index](() => {
    index++, index === scriptsToExecute.length ? callback() : insertScriptsSequentially(scriptsToExecute, callback, index);
  });
}
function simulatePageLoad($container) {
  let $scriptsRoot = document4.getElementById(SCRIPTS_ROOT_ID);
  $scriptsRoot ? $scriptsRoot.innerHTML = "" : ($scriptsRoot = document4.createElement("div"), $scriptsRoot.id = SCRIPTS_ROOT_ID, document4.body.appendChild($scriptsRoot));
  let $scripts = Array.from($container.querySelectorAll(SCRIPT));
  if ($scripts.length) {
    let scriptsToExecute = [];
    $scripts.forEach(($script) => {
      let typeAttr = $script.getAttribute("type");
      (!typeAttr || runScriptTypes.includes(typeAttr)) && scriptsToExecute.push((callback) => insertScript($script, callback, $scriptsRoot));
    }), scriptsToExecute.length && insertScriptsSequentially(scriptsToExecute, simulateDOMContentLoaded, void 0);
  } else
    simulateDOMContentLoaded();
}

export {
  isTestEnvironment,
  waitForAnimations,
  StorybookError,
  StatusTypeIdMismatchError,
  UnsupportedViewportDimensionError,
  ElementA11yParameterError,
  isPlainObject,
  isEqual,
  mapValues,
  mergeWith,
  pick,
  toMerged,
  require_main,
  enhanceArgTypes,
  SNIPPET_RENDERED,
  SourceType,
  addons,
  filterArgTypes,
  composeConfigs,
  getCsfFactoryAnnotations,
  setDefaultProjectAnnotations,
  setProjectAnnotations,
  composeStory,
  Preview,
  DocsContext,
  simulateDOMContentLoaded,
  simulatePageLoad,
  includeConditionalArg,
  definePreviewAddon9,
  isStory,
  getStoryChildren,
  sanitize,
  toId
};
//# sourceMappingURL=chunk-RE4PRD6D.js.map
